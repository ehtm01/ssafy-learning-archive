## 부분집합(powerset)
어떤 집합의 공집합과 자기 자신을 포함한 모든 부분

- 구하고자 하는 어떤 집합의 원소 개수가 n인 경우, 부분집합의 수는 2^n개이다.

### Backtracking 기법으로 powerset 만들기
- 앞에서 설명한 일반적인 Backtracking 접근 방법을 이용
- N개의 원소가 들어있는 집합의 2^n개의 부분집합
    - True 또는 False값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용
- 여기서 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값

![0819_Stack_2_2025-08-19-14-03-39](images/0819_Stack_2_2025-08-19-14-03-39.png)

```py
lst = [1, 2, 3, 4, 5]
N = 5
# 부분집합의 합이 S 이하인 부분집합 구하기
S = 5

# 부분집합을 만드는 재귀함수
def make_set(idx, selected, s):
    # 0. 가지치기
    # 부분집합의 합 s가 S보다 크면 재귀 중단
    if s > S:
        return
    
    # 1. 종료조건
    if idx == N:
        # selected 배열을 보고 선택한 원소 확인
        subset = []
        for i in range(N):
            if selected[i]:
                subset.append(lst[i])

        print(subset)
        return
    
    # 2. 재귀 호출
    # idx번 원소를 부분집합에 넣고 idx + 1번 원소 판단
    selected[idx] = 1
    make_set(idx + 1, selected, s + lst[idx])

    # idx번 원소를 부분집합에 넣지 않고 idx + 1번 원소 판단
    selected[idx] = 0
    make_set(idx + 1, selected, s)

# 0번부터 부분집합에 넣을지 고민, 아직 선택한 원소 없고 합은 0에서 시작
make_set(0, [0] * N, 0)

# 원소의 개수가 C개 이하인 부분집합만 출력
C = 2
```

### 각 원소가 부분집합에 포함되었는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법

```py
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i                  # 0번째 원소
    for j in range(2):
        bit[1] = j              # 1번째 원소
        for k in range(2):
            bit[2] = k          # 2번째 원소
            for l in range(2):
                bit[3] = l      # 3번째 원소
                print(bit)      # 생성된 부분집합 출력
```

### {1, 2, 3}의 부분집합 표현

![0819_Stack_2_2025-08-19-14-06-05](images/0819_Stack_2_2025-08-19-14-06-05.png)

### Backtracking과 부분집합

![0819_Stack_2_2025-08-19-14-11-31](images/0819_Stack_2_2025-08-19-14-11-31.png)

### Powerset을 구하는 Backtracking 알고리즘

```py
# a: 주어진 배열, k: 결정할 원소, n: 원소 개수
def backtrack(a, k, n):     
    c = [0] * MAXCANDIDATES

    if k == n:
        process_solution(a, k)      # 답이면 원하는 작업을 한다
    else:
        # co_ca: 후보 추천 함수, c: 후보군 저장
        ncandidates = construct_candidates(a, k, n, c)  
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k + 1, n)


def construct_candidates(a, k, n, c):
    c[0] = True
    c[1] = False
    return 2


def process_solution(a, k):
    for i in range(k):
        if a[i]:
            print(num[i], end=' ')
    print()


MAXCANDIDATES = 2
NMAX = 4
a = [0] * NMAX
num = [1, 2, 3, 4]
backtrack(a, 0, 3)
```

## 순열1

### 단순하게 순열을 생성하는 방법

```py
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

### Backtracking과 순열

![0819_Stack_2_2025-08-19-14-25-53](images/0819_Stack_2_2025-08-19-14-25-53.png)

### Backtracking을 이용하여 {1, 2, 3, ..., NMAX}에 대한 순열 구하기
- 접근 방법은 부분집합을 구하는 방법과 유사

```py
def backtrack(a, k, n):
    c = [0] * MAXCANDIDATES

    if k == n:
        for i in range(0, k):
            print(a[j], end=' ')
        print()
    else:
        ncandidates = construct_candidates(a, k, n, c)
        for i in range(ncandidates):
            a[k] = c[i]
            backtrack(a, k + 1, n)


def construct_candidates(a, k, n, c):
    in_perm = [False] * (NMAX + 1)

    for i in range(K):
        in_perm[a[i]] = True
    
    ncandidates = 0
    for i in range(1, NMAX + 1):
        if in_perm[i] == False:
            c[ncandidates] = i
            ncandidates += 1
    return ncandidates


MAXCANDIDATES = 3
NMAX = 3
a = [0] * NMAX
backtrack(a, 0, 3)
```

```py
lst = [1, 2, 3]
N = 3

# 자리의 주인을 지목하는 방식
# N번 인덱스에 누가 올래?: make_perm(N) -> 재귀 중단
# selected: 순열을 만들 때 이전에 사용한 원소는 사용 불가
# result: idx 단계까지 완성된 순열
def make_perm(idx, selected, result):
    # 1. 종료 조건
    if idx == N:
        print(result)
        return

    # 2. 재귀 호출
    for i in range(N):
        # i번 원소 사용한 적 없다 -> idx 위치에 사용
        if not selected[i]:
            # 순열의 idx 자리에 i번 원소 넣고 idx + 1 자리 고민
            selected[i] = 1
            result.append(lst[i])
            make_perm(idx + 1, selected, result)

            # i번 원소를 idx 자리에 놓은 경우의 수는 모두 고려함
            # i + 1번 원소 놓기 시작, i번 원소는 사용하지 않은 것으로 수정
            selected[i] = 0
            result.pop()

# 0번 자리에 누가 올래 / 고른 적 없음 / 순열 미완성
make_perm(0, [0] * 3, [])
```

## 가지치기

### 부분집합의 합
- 집합 {1, 2, 3}의 원소에 대해 각 부분집합에서의 포함 여부를 트리로 표현

![0819_Stack_2_2025-08-19-14-39-05](images/0819_Stack_2_2025-08-19-14-39-05.png)

- i 원소의 포함 여부를 결정하면 i까지의 부분집합의 합 Si를 결정할 수 있다.
- Si-1이 찾고자 하는 부분집합의 합보다 크면 남은 원소를 고려할 필요가 없음

![0819_Stack_2_2025-08-19-14-40-13](images/0819_Stack_2_2025-08-19-14-40-13.png)

- A[i] 원소를 부분집합의 원소로 고려하는 재귀 함수 (A는 서로 다른 자연수의 집합)

![0819_Stack_2_2025-08-19-14-53-19](images/0819_Stack_2_2025-08-19-14-53-19.png)

- 추가 고려 사항

![0819_Stack_2_2025-08-19-14-53-34](images/0819_Stack_2_2025-08-19-14-53-34.png)

## 순열2

### A[1, 2, 3]의 모든 원소를 사용한 순열
- 3개의 칸에 넣을 수 있는 수를 나열
- 123, 132, 213, 231, 312, 321
- 총 6가지 경우

![0819_Stack_2_2025-08-19-14-54-28](images/0819_Stack_2_2025-08-19-14-54-28.png)

### 자리 교환으로 순열 생성 1

![0819_Stack_2_2025-08-19-14-54-43](images/0819_Stack_2_2025-08-19-14-54-43.png)

```py
lst = [1, 2, 3]
N = 3

# 자리 주인 지목, 완성된 순열의 길이 3
# 0/1/.../N-1번 인덱스에 누가 올래?: make_perm()
# N번 인덱스 -> 재귀 중단
# selected: 순열을 만들 때 이전에 사용한 원소는 사용 불가, 이것을 체크하기 위한 list
def make_perm(idx, selected, result):
    # 1. 종료 조건
    if idx == N:
        print(result)
        return
    # 2. 재귀 호출
    for i in range(N):
        if not selected[i]:
            selected[i] = 1
            result.append(lst[i])
            make_perm(idx + 1, selected, result)
            # i번 원소를 idx 자리에 놓은 경우의 수 완료
            # i+1번 원소부터 시작, selected 초기화
            selected[i] = 0
            result.pop()

# 0번 자리, 고른 것 x, 순열 미완성
make_perm(0, [0] * N, [])
```

![0819_Stack_2_2025-08-19-14-54-57](images/0819_Stack_2_2025-08-19-14-54-57.png)

```py
lst = [1, 2, 3]
N = 3

# 자리 교환 방식
# 0/1/.../N-1번 인덱스랑 누가 자리 바꿀래?: make_perm()
def make_perm(idx):
    # 1. 종료 조건
    if idx == N - 1:
        print(lst)
        return
    # 2. 재귀 호출
    # idx <-> idx보다 큰 수 => 자리 바꾸는 대상 i는 idx 뒤에 있어야 함
    for j in range(idx, N):
        lst[idx], lst[j] = lst[j], lst[idx]
        make_perm(idx + 1)
        # lst 원상 복구
        lst[idx], lst[j] = lst[j], lst[idx]

make_perm(0)
```

## 분할정복

### 분할정복 알고리즘의 유래
- 1805년 12월 2일 아우스터리츠 전투에서 나폴레옹이 사용한 전략
- 전력이 우세한 연합군을 공격하기 위해 나폴레옹은 연합군의 중앙부로 쳐들어가 연합군을 둘로 나눔
- 둘로 나뉜 연합군을 한 부분씩 격파함

### 설계 전략
- 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복(Conquer): 나눈 작은 문제를 각각 해결함
- 통합(Combine): (필요하다면) 해결된 해답을 모음

### 거듭 제곱(Exponentiation)
- O(n)

![0819_Stack_2_2025-08-19-14-57-11](images/0819_Stack_2_2025-08-19-14-57-11.png)

### 분할 정복 기반의 알고리즘: O(log^2n)

![0819_Stack_2_2025-08-19-14-58-10](images/0819_Stack_2_2025-08-19-14-58-10.png)

![0819_Stack_2_2025-08-19-14-58-26](images/0819_Stack_2_2025-08-19-14-58-26.png)

### 실습
- 후위 표기법
    - 4874. Forth
- DFS
    - 4875. 미로
- 분할정복
    - 4880. 토너먼트 카드게임
- 백트래킹
    - 4881. 배열 최소 합
