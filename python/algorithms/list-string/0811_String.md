## 연산

### 문자열 뒤집기
- 문자열을 역순으로 재정의

```py
s = 'Reverse this strings'      # 'sgnirts siht esreveR'
s = s[::-1]
```

- 리스트로 변환 후 다시 문자열로 반환

```py
s = 'abcd'
s = list(s)
s.reverse()
s = ''.join(s)
```

### 회문
- "기러기", "토마토", "스위스"와 같이 똑바로 읽어도, 거꾸로 읽어도 똑같은 문장이나 낱말
    - 문자열 길이의 반만 비교하면 됨

    ![0811_String_2025-08-11-11-46-02](images/0811_String_2025-08-11-11-46-02.png)

```
is_palindrome(txt):
        for i : 0 -> len(txt)/2 - 1
                if txt[i] != txt[len(txt) - 1 - i]
                        return False
        return True
```

### 문자열 비교
- == 연산자와 is 연산자
    - ==는 값(value)이 같은지를 비교
    - is는 객체의 정체성(identity), 즉 **같은 객체**(**메모리 주소**)인지 비교
    - == 연산자는 내부적으로 특수 메서드 `__eq__()`를 호출

```py
s1 = 'abc'
s2 = 'abc'
s3 = 'def'
s4 = s1
s5 = s1[:2] + 'c'

print(s1 == s2)         # True
print(s1 is s2)         # True
print(s4 == s5)         # True
print(s4 is s5)         # False
```

### C와 Java에서의 문자열 비교
- C
    - strcmp() 함수를 사용해 문자열의 내용 비교
- Java
    - == 연산자는 객체의 주소(참조)를 비교 (Python의 is 연산자 역할)
    - equals() 메소드는 객체의 내용 비교 (Python의 == 역할)

### 사전 순서 비교
- 비교 연산자 < 사용
    - 유니코드를 비교

**두 문자열의 사전상 순서를 비교하는 my_strcmp() 함수를 구현한 예**

```py
def my_strcmp(s1, s2)
    if s1 < s2:
        return -1       # s1이 s2보다 사전 순서상 앞서는 경우
    elif s1 > s2:
        return 1        # s1이 s2보다 사전 순서상 나중인 경우
    else:
        return 0        # s1과 s2 문자열의 내용이 같은 경우
```

- 문자열에 대한 < 연산은 유니코드 값에 대한 비교이다
- 따라서 'Apple' < 'apple'도 True이고 'Zebra' < 'apple'도 True이다

### 문자열 숫자를 숫자로 변환
1. 문자열을 숫자로 변환하는 예

```py
a = int('123')
b = float('3.14')
c = int('A0', 16)       # 문자열 'A0'를 16진법으로 해석해서 변환
```

2. 숫자를 문자열로 변환하는 예

```py
a = str(123)
b = str(3.14)
```

# 패턴 매칭

## 고지식한 패턴 검색

### 고지식한 알고리즘(Brute Force)
- 단순한 방법
    - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식

    ![0811_String_2025-08-11-15-14-58](images/0811_String_2025-08-11-15-14-58.png)

### 구현
- 본문의 비교위치 i, 패턴에서의 비교위치 j
    - 일치하면 i,j 증가, 실패하면 i는 이전 시작위치 다음으로, j는 맨 앞으로 초기화

    ![0811_String_2025-08-11-15-15-43](images/0811_String_2025-08-11-15-15-43.png)

### 코드

```py
def brute_force(p, t):  # p 찾을 패턴, t 본문 문자열, 패턴이 있으면 인덱스, 없으면 -1 리턴
    i = 0   # t의 인덱스
    j = 0   # p의 인덱스
    M = len(p)
    N = len(t)
    while j < M and i < N:
        if t[i] != p[j]:        # 다른 글자인 경우
            i = i - j
            j = -1
        i = i + 1
        j = j + 1
    if j == M: return i - M     # 검색 성공
    else: return -1             # 검색 실패
```

### 시간 복잡도
- 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨
- 길이가 10,000인 문자열에서 길이 80인 패턴을 찾는 경우
    - 최악의 경우 약 10,000 * 80 = 800,000 번의 비교가 필요

## KMP 알고리즘
- 연구자인 Knuth, Morris, Pratt 세 사람의 이름에서 유래

- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
    - 불일치가 발생한 글자의 앞 부분에 어떤 문자가 있는 지를 미리 알고 있게 된다
    - 조건에 따라, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않을 수 있음
    - 불일치가 발생했을 경우, 이동할 다음 위치를 게산하는 <mark>전처리</mark>가 필요

- 시간 복잡도
    - 패턴의 길이가 M일 때 전처리에 걸리는 시간은 O(M)
    - 텍스트의 길이가 N일 때 검색은 최악의 경우 O(N)
    - 결과적으로 O(M+N)
    - 만약 M이 고정된 값으로 매우 짧다면 평균적으로 Θ(N)

### 아이디어
- 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황
    - 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있음

    ![0811_String_2025-08-11-15-58-00](images/0811_String_2025-08-11-15-58-00.png)

### LPS(Longest Prefix which is also Suffix) 배열
- 접두사이자 접미사인 문자열의 최대 길이
- 일치하지 않을 때 비교할 인덱스
- 구현에 따라 next, pi 배열로도 불림

![0811_String_2025-08-11-15-58-57](images/0811_String_2025-08-11-15-58-57.png)

<details>
<summary> LPS 심화 학습 </summary>
<div markdown="1">

## LPS(Longest Prefix which is also Suffix) 배열, 제대로 이해하기

- LPS는 **문자열 P의 각 접두사에 대해 “자기 자신과 같은 접미사”의 최장 길이**를 적어 둔 배열
- *proper prefix/접두사*는 **전체 문자열과 동일하면 안 된다**는 조건이 붙음
- 보통 `lps[i]`는 `P[0..i]`(0\~i까지 부분문자열)의 최장 접두사 == 접미사의 **길이**를 뜻함

- 필요성: KMP 문자열 검색에서 **불일치가 발생했을 때 어디로 점프할지**를 알려주는 점프 테이블이 바로 LPS이다
- 중복 비교를 없애서 전체 시간복잡도를 `O(N+M)`으로 만든다

---

### 빠른 감 잡기

- 문자열 `P = "ABABACA"`
- 각 위치까지의 부분문자열에 대해 접두사 == 접미사 최장 길이를 채운다

| i | 문자 | 부분문자열 P\[0..i] | 접두사 == 접미사 최장 | lps\[i] |
| - | -- | -------------- | ----------- | ------- |
| 0 | A  | A              | 없음          | 0       |
| 1 | B  | AB             | 없음          | 0       |
| 2 | A  | ABA            | A           | 1       |
| 3 | B  | ABAB           | AB          | 2       |
| 4 | A  | ABABA          | ABA         | 3       |
| 5 | C  | ABABAC         | 없음          | 0       |
| 6 | A  | ABABACA        | A           | 1       |

그래서 LPS는 `[0, 0, 1, 2, 3, 0, 1]`

- 5번째 자리(C)에서 깨진 뒤 **그냥 0으로 리셋하는 게 아니라**, 보통은 직전의 길이를 `lps`로 되돌아가며 맞춰 본다
- 이 예시는 바로 0이 됐지만, 일반적으로는 `길이 = lps[길이-1]`로 “점프 백트래킹”을 반복

---

### LPS 계산 알고리즘 (직관 버전)

두 포인터 느낌으로 보면 쉽다

* `len`: 현재까지 맞아온 “접두사==접미사”의 길이
* `i`: 현재 채울 인덱스 (1부터 시작)

절차:

1. `P[i] == P[len]`면 둘 다 한 칸 전진

   → `len += 1`, `lps[i] = len`, `i += 1`

2. `P[i] != P[len]`인데 `len > 0`이면

   → `len = lps[len-1]`로 **점프**하고 다시 비교

3. `P[i] != P[len]`이고 `len == 0`이면

   → `lps[i] = 0`, `i += 1`

시간복잡도는 `O(M)`

---

### 파이썬 구현 (실전용)

```python
def build_lps(p: str) -> list[int]:
    lps = [0] * len(p)
    length = 0  # 현재까지 일치한 길이
    i = 1       # lps[0]은 항상 0

    while i < len(p):
        if p[i] == p[length]:
            length += 1
            lps[i] = length
            i += 1
        elif length != 0:
            # 길이를 줄여 다시 시도 (접두사 길이를 접미사 후보로 점프)
            length = lps[length - 1]
        else:
            lps[i] = 0
            i += 1
    return lps

# 예시
print(build_lps("ABABACA"))  # [0, 0, 1, 2, 3, 0, 1]
```

---

### 자주 헷갈리는 부분

* **“proper(진) 접두사”**: 전체 문자열과 같은 건 금지. 예를 들어 `"aaaa"`에서 `lps`는 `[0,1,2,3]`이지만, 전체 길이 4는 절대 들어가지 않는다.
* **불일치 시 무조건 0이 아님**: `length = lps[length-1]`로 점프한 뒤 다시 비교한다. 이게 KMP의 가속 핵심.
* **0/1 인덱스 혼동**: `lps[0] = 0`부터 확실히 고정하고 출발하면 깔끔하다.

</div>
</details>

---

## 보이어-무어(Boyer-Moore) 알고리즘
- 상용 소프트웨어에서 채택하고 있는 알고리즘
- 실제 검색에서 매우 빠른 성능
    - 패턴 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이만큼이 된다

    ![0811_String_2025-08-11-17-11-37](images/0811_String_2025-08-11-17-11-37.png)

### 불일치 문자 휴리스틱(Bad-Character Heuristic)
- 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재할 경우
    - 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프
    
    ![0811_String_2025-08-11-17-12-57](images/0811_String_2025-08-11-17-12-57.png)

### Skip 배열

![0811_String_2025-08-11-17-13-16](images/0811_String_2025-08-11-17-13-16.png)

### 문자열 매칭 알고리즘 비교
- 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
- 고지식한 패턴 검색 알고리즘: 수행시간 O(mn)
- 카프-라빈 알고리즘: 수행시간 Θ(n)
- KMP 알고리즘: 수행시간 Θ(n)
- 보이어-무어 알고리즘
    - 앞의 두 매칭 알고리즘들은 텍스트 문자열의 문자를 적어도 한 번씩 훑기 대문에 최선의 경우에도 Ω(n)
    - 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 됨
    - 패턴의 오른쪽부터 비교
    - 완전한 보이어-무어 알고리즘은 일치 접미부 휴리스틱을 함께 사용
    - 최악의 경우 O(mn)이지만, 일반적으로 <mark>Θ(n)보다 시간이 덜 듦</mark>
    - grep, VS Code, JVM 등에서 사용된다고 알려짐

## 문자열 암호화

### 시저 암호(Caesar cipher)
- 줄리어스 시저가 사용했다고 하는 암호
- 시저는 기원전 100년경에 로마에서 활약했던 장군
- 시저 암호에서는 평문에서 사용되고 있는 알파벳을 일정한 문자 수만큼 **평행이동**시킴으로써 암호화
- 1만큼 평행한 암호화의 예

**평문**|S|A|V|E| |P|R|I|V|A|T|E| |R|Y|A|N
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
**암호문**|T|B|W|F|A|Q|S|J|W|B|U|F|A|S|Z|B|O

- -1만큼 평행했을 때 1을 키 값이라고 한다
- 수신자 이외의 사람(키가 1이라는 사실을 모르는 사람)이 암호문 TBWFAQSJWBUFASZBO를 보고 SAVE PRIVATE RYAN 이라는 메시지를 맞출 수 있을까?

### 시저 암호문에 대한 전사공격
- 모든 키 값을 사용해 해석 시도
- 대문자만 사용한다는 것은 알고 있음

![0811_String_2025-08-12-08-49-12](images/0811_String_2025-08-12-08-49-12.png)

### 문자 변환표를 이용한 암호화 (단일 치환 암호화)
- 단순한 카이사르 암호화보다 훨씬 강력한 암호화 기법
    - 알파벳 하나를 다른 고정된 알파벳으로 바꾸는 방법

![0811_String_2025-08-12-08-50-34](images/0811_String_2025-08-12-08-50-34.png)

### 단일 치환 암호화의 복호화
- 모든 키의 조합이 필요
- 키의 총 수
    - 26 * 25 * 24 * 23 * ... * 1 = 26! = 403291461126605635584000000
    - 1초에 10억 개의 키를 적용할 수 있어도 120억년 이상 걸림

- 빈도 분석 공격 가능
    - 가장 많이 쓰이는 글자 E, T, A 등임
    - 암호문에서 자주 나오는 문자를 추정해 대응시키면 해독 가능

### 문자열 압축
- Run-length encoding 알고리즘
    - 같은 값이 몇 번 반복되는가를 나타내는 방식
    - 이미지 파일 포맷 중 BMP 파일의 압축 방법 중 하나로 사용

    ![0811_String_2025-08-12-08-58-23](images/0811_String_2025-08-12-08-58-23.png)

- 허프만 코딩 알고리즘
    - 더 효율적이고 일반적인 압축 방법
    - 자주 나오는 문자는 짧은 코드, 드물게 나오는 문자는 긴 이진 코드를 부여해, 결과적으로 전체 데이터의 평균 비트 수를 최소화하는 알고리즘

### 실습
- 문자열
    - 4865. 글자수
- 회문
    - 1989. 초심자의 회문 검사
    - 4861. 회문
- 패턴 매칭
    - 4864. 문자열 비교(고지식한 방법으로)
    - 3143. 가장 빠른 문자열 타이핑
- 추가 연습
    - <mark>5356. 의석이의 세로로 말해요</mark>
    - <mark>5432. 쇠막대기 자르기</mark>