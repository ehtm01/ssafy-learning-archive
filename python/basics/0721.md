# 프로그래밍

## 프로그래밍이란

### 프로그램
문제를 해결하기 위한 명령어들의 집합
- 친구에게 우리 집으로 오는 길을 적어주는 것 -> 프로그램 작성
  - 적어준 길을 순서대로 따라가는 것 -> 프로그램 실행
- 프로그램은 이처럼 몇 가지 기초 연산으로 구성됨
  - 'xx 사거리에서 우회전', '두 블록 직진 후 좌회전' 등
- 컴퓨터는 더 다양한 연산 집합을 가짐
  - '파일에서 3번쨰 줄을 지워라', '네모 박스를 오른쪽으로 옮겨라' 등
  - 기존 연산을 사용해 더 많은 연산을 만들 수도 있음
  - 이전에 사용한 연산 위에 차곡차곡 쌓여 새로운 연산을 만들어 냄

### 프로그래밍의 핵심
새 연산을 정의하고 조합해 유용한 작업을 수행하는 것

## 프로그래밍 언어
컴퓨터에게 작업을 지시하고 문제를 해결하는 도구

## Python

### Python을 배우는 이유
- 쉽고 간결한 문법
  - 읽기 쉽고 쓰기 쉬운 문법을 가지고 있어 쉽게 배우고 활용할 수 있음
- Python 커뮤니티의 지원
  - 세계적인 규모의 풍부한 온라인 포럼 및 커뮤니티 생태계를 형성함
- 광범위한 응용 분야
  - 웹 개발, 데이터 분석, 인공지능, 자동화 스크립트 등 다양한 분야에서 사용함
- 프로그래밍과 인공지능에서 기본 언어로 가장 많이 사용되는 언어

*왜 인공지능(AI)과 머신러닝(ML) 개발에 Python을 사용할까?*
- 압도적인 전문 라이브러리
  - **TensorFlow**, **Pytorch** 등 AI 개발의 핵심 도구들이 파이썬으로 제공되어, 복잡한 기능을 쉽게 구현할 수 있음
- 쉬운 문법과 높은 생산성
  - 문법이 간결하여 배우기 쉽고, 아이디어를 빠르게 프로토타입으로 만들 수 있어 연구와 개발에 가장 효율적
- 강력한 커뮤니티와 생태계
  - 수많은 개발자들이 파이썬을 사용하므로 관련 자료를 찾기 쉽고 문제 해결에 대한 도움을 얻기 용이

## Python 실행
- 컴퓨터는 기계어로 소통하기 때문에 사람이 기계어를 직접 작성하기 어려움
- 인터프리터가 사용자의 명령어를 운영체제가 이해하는 언어로 바꿈

### Python 인터프리터 사용법
- shell 이라는 프로그램으로 한 번에 한 명령어씩 입력하여 실행
- 터미널을 켜고 python -i를 입력하면 파이썬 인터프리터 환경이 실행

```
- python -i

  - 인터프리터 환경을 실행

- >>>

  - Python shell의 입력 프롬포트, 이 상태에서 명령어를 직접 입력할 수 있음
```

- 확장자가 .py인 파일에 작성된 Python 프로그램 실행

```
나갈때 exit() = kill terminal(휴지통)

디버깅 모드 -> Run 자주 사용
```

## 표현식과 값

### 표현식
- 하나의 **'값'으로 평가**될 수 있는 모든 코드

```
3 + 5

x > 10

5 * 4
```

### 값(Value)
- 표현식이 **평가**된 결과
- 더 이상 계산되거나 평가될 수 없는, 프로그램의 가장 기본적인 데이터 조각

```
숫자 값 : 103.14

문자열 값 : '안녕하세요'

불리언 값 : True, False
```

|개념|설명|
|:-:|:-:|
|표현식|3 + 5 같은 값으로 평가 될 수 있는 코드|
|평가|표현식을 계산하여 값을 만들어 냄|
|값|표현식이 평가된 결과|

## 변수와 메모리

### 변수(Variable)
값을 나중에 다시 사용하기 위해, 그 값에 붙여주는 고유한 이름, **객체를 가리키는 이름**

### 변수 할당(Variable assignment)  
표현식이 만들어 낸 값에 이름을 붙이는 과정(연결)

### 할당문 (Assignment Statement)
- '값 36.5을 **변수** degrees에 할당했다.'

```
degrees = 36.5
```

|요소|설명
|:-:|:-:
|degrees|변수 이름
|=|할당 연산자 (오른쪽 표현식의 평가 결과 값을 왼쪽 변수에 저장)
|36.5|표현식

### 변수명 규칙
- 영문 알파벳, 언더스코어(_), 숫자로 구성
- 숫자로 시작할 수 없음
- 대소문자를 구분
- 내부 예약어는 변수로 사용할 수 없음

### 변수, 값 그리고 메모리
- 거리에 집 주소가 있듯이 메모리의 모든 위치에는 그 위치를 고유하게 식별하는 **메모리 주소**가 존재
- 고유한 ID (메모리 주소)
  - 제품의 바코드
- 타입 (Type)
  - 제품의 종류 (예: '정수', '실수', '문자열' 등)
- 값 (Value)
  - 제품의 실제 내용물
- 값+타입+주소 정보를 묶은 것을 **객체(Object)**라고 부름
- 변수는 특정 개체를 '가리키는(refer/point to)' 이름표

***변수는 메모리 주소를 '가지지(contain)' 않는다.***

### 할당문 동작 순서

```
Variable = expression
```

1. 오른쪽 표현식 평가
  - 가장 먼저, 할당 연산자(=)의 오른쪽에 있는 표현식 전체를 계산, 하나의 결과값(객체) 만듦
2. 왼쪽 변수명 확인
  - 이름이 처음 사용: 새로운 '이름표' 준비
  - 이미 존재하는 이름: 기존 '이름표' 사용
3. 변수명과 결과값 연결(참조)
  - 마지막으로, 왼쪽의 변수명이 오른쪽에서 만들어진 결과값 가리키도록 연결
  - 만약 변수명이 이전에 다른 객체를 가리키고 있었다면, 그 연결은 끊어지고 새로운 객체와의 연결만 남음(재할당)

### 재할당
이미 값이 할당된 변수에 새로운 값을 다시 할당 하는 것
- 변수는 특정 값을 '기억'하거나 '가리키는' 이름
- 재할당은 이 변수가 가리키는 대상을 새로운 값으로 변경하는 행위

```
degrees = 'hello'
```

### 재할당 점검
- 변수 double의 값은 무엇일까?

```
number = 10
double = 2 * number
print(double) #20

number = 5
print(double) #??
```

|용어|핵심 정의|비유 (주소록)
|:-:|:-:|:-:
|객체 (Object)|데이터(값, 타입, 행동)의 실체|'김철수'라는 실제 사람
|메모리 주소|객체가 저장된 고유한 위치|김철수의 실제 집 주소
|변수 (Variable)|객체를 가리키는 이름표|주소록에 저장된 '내 친구 철수'라는 이름

# Data Types

## 타입
변수나 값이 가질 수 있는 데이터의 종류를 의미

### 타입의 구성 요소
```
      1       +       2
     (값)  (연산자)
'값'과 '값에 적용할 수 있는 연산'
```

### Data Types
값의 종류와 그 값으로 할 수 있는 '동작(연산)'을 결정하는 속성

*데이터 타입이 필요한 이유*
- 각 타입에 따라 가능한 기능과 연산이 다르기 때문

*데이터 타입 분류 5가지*
- Numeric Types
  - int(정수), float(실수), ~~complex(복소수)~~
- Text Sequence Type
  - str (문자열)
- Sequence Types
  - list, tuple, range
- Non-sequence Types
  - set, dict
- 기타
  - Boolean, None, Functions

## Numeric Types
*숫자형 데이터* : 프로그래밍에서 값을 계산하고 수량을 세고, 데이터를 분석하는 등 가장 기본이 되는 데이터 타입

## int (정수 자료형)
소수점이 없는 숫자를 표현 (양수, 0, 음수 포함)

## float (실수 자료형)
소수점이 있는 더 정밀한 숫자를 표현

### 지수 표현법
- 아주 크거나 아주 작은 실수를 간결하게 표현하기 위해 사용하는 방식
- 'e' 또는 'E'를 사용

## 숫자형의 '행동': 산술 연산
- 숫자형 데이터의 핵심 '행동'은 바로 계산
- 데이터 타입은 '값의 종류'와 '적용 가능한 행동'의 묶음
- 파이썬은 다양한 계산을 위한 산술 연산자를 제공

### 산술 연산자
- 가장 기본이 되는 연산

|기호|설명
|:-:|:-:
|+|덧셈
|-|뺄셈
|*|곱셈
|/|나눗셈
|//|몫 나눗셈
|%|나머지
|**|거듭제곱
|-|음수 부호

### 연산자 우선순위
- 수학과 마찬가지로, 파이썬도 정해진 순서에 따라 연산을 수행

|우선순위|연산자|연산
|:-:|:-:|:-:
|높음|**|지수
||-|음수 부호
||*, /, //, %|곱셈, 나눗셈, 정수 나눗셈, 나머지
|낮음|+, -|덧셈, 뺄셈

- 순서가 헷갈릴 때는 소괄호'()'를 사용해서 원하는 연산을 먼저 수행하도록 명시하는 것이 가장 좋다.

```
(2 + 3) * 4 -> 20
```

### 연산자 우선순위 점검
- 각 표현식의 결과는?

```
# ?
-2 ** 4
-(2 ** 4)
(-2) ** 4
```

## Sequence Types
여러 개의 값들을 순서대로 나열하여 저장하는 자료형
- 모든 칸에는 0번부터 시작하는 고유한 번호(**인덱스**)가 붙음

### 시퀀스 타입의 5가지 공통 특징
1. 순서(Order)
  - 값들이 순서대로 저장 (정렬 X)
2. 인덱싱(Indexing)
  - 각 값에 고유 번호(인덱스)를 가지고 있으며, 인덱스를 사용하여 특정 위치의 값을 선택하거나 수정할 수 있음
3. 슬라이싱(Slicing)
  - 인덱스 범위를 조절해 전체 데이터 중 원하는 부분만 값을 잘라내서 사용할 수 있음
4. 길이(Length)
  - len() 함수를 사용해 저장된 값의 개수(길이)를 구할 수 있음
5. 반복(Iteration)
  - 반복문을 사용하여 각 값을 하나씩 순서대로 꺼내 사용할 수 있음

### 시퀀스 타입 특징 예시
- my_data = 'Hello'라는 문자열 데이터가 있을 때

|특징|사용 예시|결과
|:-:|:-:|:-:
|인덱싱|my_data[1]|'e'
|슬라이싱|my_data[1:4]|'ell'
|길이|len(my_data)|5
|반복|for char in my_data:|H, e, l, l, o가 차례로 출력

## str (문자열)
문자들의 순서가 있는 변경 불가능한 시퀀스 자료형

## 문자열 만들기
- 작은따옴표(') 또는 큰따옴표(")로 감싸서 표현

```
# Hello, World!
print('Hello, World!')

# ste
print(type('Hello, World!'))
```

- 따옴표 안에 다른 따옴표를 넣고 싶을 때는 서로 다른 종류의 따옴표를 사용
- 이스케이프 시퀀스(Escape Sequence)
  - 역슬래시(\\)와 문자를 조합해 특별한 기능을 수행 (e.g. 줄바꿈, 탭)

### 이스케이프 시퀀스 예약 문자 정리

|예약 문자|기능
|:-:|:-:
|\n|줄 바꿈
|\t|탭
|\\\ |백슬래시
|\\'|작은 따옴표
|\\"|큰 따옴표

## 문자열에 값 삽입하기: f-string
문자열 내에 변수나 표현식의 결과를 손쉽게 삽입하는 강력한 방법

### f-string 사용법
- 문자열 시작 전 'f' 접두어를 붙이고, 삽입할 부분(표현식)을 중괄호{}로 감싸줌

```
name = '홍길동'
age = 25

greeting = f'안녕하세요, 제 이름은 {name}이고 나이는 {age}살입니다.'

# 안녕하세요, 제 이름은 홍길동이고 나이는 25살입니다.
print(greeting)
```

> ## `f-string 추가 학습`

### 1. 기본 사용법

```
name = "철수"
age = 25
print(f"{name}는 {age}살입니다.")
# 철수는 25살입니다.
```

- `f'...'` 안에서 중괄호 `{}`를 사용해 변수나 표현식을 직접 삽입할 수 있다.

### 2. 표현식도 가능

```
print(f"내년 나이는 {age + 1}살입니다.")
# 내년 나이는 26살입니다.
```

- 계산, 함수 호출, 조건식 등도 직접 넣을 수 있다.

### 3. 정렬 및 폭 지정

```
name = "지수"
print(f"{name:>10}")   # 오른쪽 정렬
print(f"{name:<10}")   # 왼쪽 정렬
print(f"{name:^10}")   # 가운데 정렬
```

| 포맷     | 설명             |
| :------: | :--------------: |
| `:>10` | 10칸 폭에서 오른쪽 정렬 |
| `:<10` | 왼쪽 정렬          |
| `:^10` | 가운데 정렬         |

### 4. 숫자 포맷팅

```
pi = 3.141592
print(f"{pi:.2f}")     # 소수 둘째 자리까지
print(f"{1000000:,}")  # 천 단위 콤마
```

- :.2f -> 소수점 둘째 자리
- :, -> 천 단위 콤마

### 5. 이진수, 16진수 등

```
num = 42
print(f"{num:b}")   # 101010 (2진수)
print(f"{num:o}")   # 52 (8진수)
print(f"{num:x}")   # 2a (16진수, 소문자)
print(f"{num:X}")   # 2A (16진수, 대문자)
```

### 6. 사전 및 객체 접근

```
person = {'name': '영희', 'age': 30}
print(f"{person['name']}의 나이는 {person['age']}세입니다.")
```

또는 클래스 객체에도 사용 가능:

```
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

p = Person("민수", 27)
print(f"{p.name}는 {p.age}살입니다.")
```

### 7. 여러 줄에서 f-string 사용 (f 앞에 붙이기)

```
name = "수빈"
age = 28
message = (
    f"이름: {name}\n"
    f"나이: {age}\n"
    f"환영합니다!"
)
print(message)
```

### 8. 중괄호 출력

```
value = 10
print(f"값은 {{ {value} }}입니다.")
# 값은 { 10 }입니다.
```

중괄호 `{}` 자체를 출력하고 싶으면 중괄호를 **두 번 씁니다**: `{{`와 `}}`

### 9. datetime 포맷팅

```
from datetime import datetime
now = datetime.now()
print(f"{now:%Y-%m-%d %H:%M:%S}")
# 2025-07-22 14:25:00 (예시)
```

### 10. 리스트나 조건식 응용

```
score = 85
print(f"합격 여부: {'합격' if score >= 60 else '불합격'}")
```

### 번외: 함수 안에서도 사용 가능

```
def greet(name):
    return f"안녕하세요, {name}님!"

print(greet("정우"))
```





## 시퀀스로서의 문자열
- 문자열은 시퀀스이므로 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있음

|특징|사용 예시|결과|설명
|:-:|:-:|:-:|:-:
|인덱싱|my_data[1]|'e'|1번 위치의 글자 선택
|슬라이싱|my_data[1:4]|'ell'|1번부터 4번 앞까지 부분 추출
|길이|len(my_data)|5|문자열의 전체 길이
|반복|for char in my_data:|H, e, l, l, o|각 문자를 순서대로 처리

### 인덱스
시퀀스 자료형에서 각 값의 위치를 식별하기 위해 부여된 고유한 번호

*인덱스는 왜 0부터 시작할까요?*

프로그래밍에서 인덱스가 0부터 시작하는 것 -> '거리'의 개념

- 인덱스는 '시작점으로부터 얼마나 떨어져 있는가'를 의미
- 첫 번쨰 값은 시작점, 거리 = 0
- 두 번쨰 값은 시작점에서 1만큼 떨어짐

따라서 index 0은 '첫 번쨰 항목'을 의미, 대부분의 프로그래밍 언어에서 통용됨

- 파이썬은 다른 언어와 달리 **음수 인덱스**를 지원함
- -1은 맨 마지막 값을 의미함

### 슬라이싱(Slicing)
시퀀스의 일부분을 잘라내어 새로운 시퀀스를 만드는 작업

### 슬라이싱 사용 방법
- 대괄호 [] 안에 시작 위치, 끝 위치, 간격(step)을 콜론(:)으로 구분하여 지정

```
my_sequence[start:stop:step]
```

1. start: 슬라이싱을 시작할 인덱스 (포함됨)
2. stop: 슬라이싱을 끝낼 인덱스 (포함되지 않음)
3. step: 몇 개씩 건너뛰며 값을 가져올 지에 대한 간격

## 문자열의 불변성

### 문자열(str)
문자들의 순서가 있는 **변경 불가능**한 시퀀스 자료형

*그럼 문자열을 바꾸려면?*

- 기존 문자열의 일부와 새로운 값을 조합하여 **새로운 문자열을 만들어야 함**

*my_str = 'Hallo'로 작성하면 변경된 것 아닌가요?*

- 아닙니다.
- 그것은 my_str을 변경한 것이 아니라 새로운 값으로 '**재할당**'한 것입니다.

# 참고

## 정수형의 진법 표현

### 코드에서 진법 표현하기
- 파이썬은 코드 내에서 다양한 진법의 숫자를 직접 표현할 수 있도록 특별한 접두사(prefix)를 제공

|진법|접두사|사용하는 숫자/문자|
|:-:|:-:|:-:|
|2진수(binary)|0b|0과1|
|8진수(hexadecimal)|0o|0부터 7까지|
|16진수(hexadecimal)|0x|0부터 9, a부터 f까지|

## 실수의 함정, 부동소수점 오차

### 실수의 이상한 계산 결과
- 왜 변수 result의 값은 0.3이 아닐까? 컴퓨터의 실수 처리방식을 이해해야 합니다.

### 부동소수점 (반올림) 오차 (Floating-point Rounding Error)
- 발생 원인
1. 컴퓨터는 2진법 사용
  - 컴퓨터는 모든 숫자를 0과 1로 이루어진 2진수로 변환하여 저장
2. 무한 소수의 발생과 근사값 저장
  - 우리가 쓰는 10진수 소수 중 일부(예: 0.1)는 2진수로 바꾸면 무한히 반복되는 무한 
  소수가 됨
  - 0.1 (10진수) -> 0.0001100110011~ (2진수)
  - 메모리는 유한하기 때문에, 컴퓨터는 이 무한 소수를 어쩔 수 없이 가장 가까운 근사값으로 잘라서 저장함

### 해결책: 정확한 계산이 필요할 때
- 대표적으로 decimal 모듈을 사용해 부동소수점 연산의 정확성을 보장하는 방법
- decimal은 실수를 2진수로 변환하지 않고, 10진수 자체로 정확하게 연산할 수 있게 해줌

> ## `다양한 해결 방법 확인해보기`

### 1. 반올림(`round`) 사용
```
print(round(0.1 + 0.2, 2)) # 출력: 0.3
```
- **장점**: 간단함
- **단점**: 누적된 오차에는 취약할 수 있음

### 2. `decimal` 모듈 사용
정확한 소수 연산이 필요할 경우 사용

```
from decimal import Decimal, getcontext

getcontext().prec = 28  # 원하는 정밀도 설정
a = Decimal('0.1')
b = Decimal('0.2')
print(a + b)  # 출력: 0.3
```

- **장점**: 정밀도 매우 높음
- **단점**: 성능 저하, 문자열로 숫자를 줘야 함

### 3. `fractions` 모듈 사용
유리수(분수)로 정확한 계산이 필요할 때 사용

```
from fractions import Fraction

a = Fraction(1, 10)
b = Fraction(2, 10)
print(a + b)  # 출력: 3/10
```

- **장점**: 정확한 수학적 계산
- **단점**: 결과가 분수형 (출력 전 float()로 변환 가능)

### 4. `math.isclose()` 또는 `numpy.isclose()` 사용
실수 비교 시에는 직접 비교하지 말고, **오차 허용 범위**를 지정해서 비교해야 한다.

```
import math

print(math.isclose(0.1 + 0.2, 0.3))  # 출력: True
```

- **장점**: 비교 시 매우 안정적
- **단점**: 연산 정확도 자체를 높이지는 않음

| 방법               | 용도/장점           | 예시                                |
| :---------------: | :---------------: | :---------------------------------: |
| `round()`        | 단순 출력 또는 임시 계산용 | `round(x, 2)`                     |
| `decimal`        | 금융/통화 등 정밀 계산   | `Decimal('0.1') + Decimal('0.2')` |
| `fractions`      | 정확한 수학적 분수 계산   | `Fraction(1, 3)`                  |
| `math.isclose()` | 실수 비교           | `math.isclose(a, b)`              |

## 표현식과 문장

### 문장 (Statement)
특정 '동작(action)'을 지시하는, 실행 가능한 코드의 최소 단위

***표현식 vs 문장이 헷갈린다면?***

- "이 코드를 실행하면, 그래서 '하나의 값'이 남나요?"
- 표현식 -> 네
  - 어떻게든 계산되거나 평가되어 **하나의 값으로 귀결**됨 (변수에 담을 수 있음)
  - 10 + 20 -> 값 30이 남음
  - len("hello") -> 값 5가 남음
- 문장 -> 아니오
  - 컴퓨터에게 특정 동작을 '지시'하고 끝남 (값 자체가 남지 않음)
  - name = "홍길동" -> 값을 변수에 할당하라는'지시'

### 관계도: 문장은 표현식을 '재료'로 사용한다.
- 문장 == 요리법
  - 요리의 전체적인 절차와 구조를 나타냄 (예: "재료를 섞고 오븐에 구워라.")
- 표현식 == 재료
  - 요리에 필요한 구체적인 값 (예: "밀가루 500g", "계란 3개")
- "요리법(문장)에 재료(표현식)가 사용될 수 있고, 때로는 재료(표현식) 하나만으로도 간단한 요리(문장)가 될 수 있다.

***total_price = 5000 + 1500 할당문 예시***

- 5000 + 1500
  - 값 6500을 만들어내는 '표현식'
- total_price = ...
  - 표현식이 만든 값을 변수에 할당하라고 지시하는 '문장'

## Style Guide
코드의 일관성과 가독성을 향상시키기 위한 규칙과 권장 사항들의 모음
- 파이썬에서는 **PEP 8**이 가장 대표적인 스타일 가이드

### 파이썬에서의 대표적인 Style Guide
- 변수명은 무엇을 위한 변수인지 직관적인 이름 사용
- 공백(spaces) 4칸을 사용하여 코드 블록 들여쓰기
- 한 줄의 길이는 79자로 제한, 길어질 경우 줄 바꿈 사용
- 문자와 밑줄(_)을 사용하여 함수, 변수, 속성의 이름 작성
- 함수 정의, 클래스 정의 등의 블록 사이에는 빈 줄 추가

> ## '그 외 다양한 규칙`

### 1. 불필요한 공백 피하기
- 연산자, 쉼표, 괄호 등에서 불필요한 공백을 피해야 한다.

```
# bad
x             = 1
y=2
z = x  +  y

# good
x = 1
y = 2
z = x + y
```

### 2. Import는 항상 최상단에
- 표준 라이브러리 -> 서드파티 -> 로컬 모듈 순으로 구분하여 그룹화
- 그룹 사이엔 **빈 줄 1개**를 넣는다.

```
# good
import os
import sys

import numpy as np
import requests

from mymodule import myfunc
```

### 3. 함수 및 클래스 정의 간 간격
- **함수 사이에는 빈 줄 2개**, 클래스 안의 메서드 사이에는 빈 줄 1개

```
# good
def func_a():
    pass


def func_b():
    pass


class MyClass:
    def method_a(self):
        pass

    def method_b(self):
        pass
```

### 4. 괄호 사용과 줄바꿈
- 긴 인자 목록은 괄호로 감싸고, 각 줄마다 들여쓰기한다.

```
# good
result = some_function(
    long_argument_1,
    long_argument_2,
    long_argument_3,
)
```

### 5. 불변 값에 상수 이름 사용
- 상수는 모두 **대문자**와 밑줄로 표기

```
MAX_RETRIES = 5
API_KEY = "abcdefg"
```
### 6. 이름 규칙(Naming Conventions)

| 항목       | 예시                           | 설명             |
| :--------: | :----------------------------: | :--------------: |
| 변수/함수명   | `snake_case`                 | 소문자+밑줄         |
| 클래스명     | `CamelCase`                  | 각 단어의 첫 글자 대문자 |
| 상수명      | `UPPER_SNAKE_CASE`           | 전부 대문자+밑줄      |
| "비공개" 변수 | `_single_leading_underscore` | 내부용 의미         |
| "매직 메서드" | `__init__`, `__str__`        | 특별한 예약 이름      |

### 7. 리스트/딕셔너리/셋 등은 줄마다 요소를 정렬 가능

```
# good
settings = {
    "debug": True,
    "logging": False,
    "theme": "dark",
}
```

### 8. Boolean 값 비교는 `is`, `is not` 사용

```
# good
if flag is True:
    pass

# 또는
if value is None:
    pass
```

### 9. 람다 대신 def 사용 권장
람다는 너무 복잡한 표현에서는 지양합니다.

```
# bad
items.sort(key=lambda x: x[1] + x[2] * x[3])

# good
def custom_key(x):
    return x[1] + x[2] * x[3]

items.sort(key=custom_key)
```

### 10. 주석 작성 규칙
- **코드를 설명하는 주석**을 적절하게 달되, **코드 자체가 설명적이라면 생략 가능**
- 주석은 **전체 코드의 맥락에 맞는 설명**이어야 함

```
# bad (설명력이 없음)
# increment i
i += 1

# good
# Increase i to account for the new item
i += 1
```

### 요약

| 범주     | 규칙 예시                                                         |
| :------: | :-------------------------------------------------------------: |
| 공백     | 연산자, 괄호, 쉼표 옆 불필요한 공백 지양                                      |
| 들여쓰기   | 공백 4칸                                                         |
| 줄 수 제한 | 한 줄에 79자                                                      |
| 빈 줄    | 함수는 2줄, 메서드는 1줄                                               |
| 이름 규칙  | 함수/변수는 `snake_case`, 클래스는 `CamelCase`, 상수는 `UPPER_SNAKE_CASE` |
| 주석     | 의미 있는 설명만 작성                                                  |

## 주석
프로그램 코드 내에 작성되는 설명이나 메모
- 주석 처리된 부분은 프로그램 실행에 아무런 영향을 주지 않음 ('#' 기호를 사용)
- 코드의 복잡한 로직을 설명하거나 특정 부분을 잠시 비활성화할 때 유용하게 사용

## [Python tutor](https://pythontutor.com/)
파이썬 코드가 한 줄씩 어떻게 실행되는지 눈으로 보여주는 시각화 도구
- 코드를 작성 후 'render all objects on the heap' 옵션을 선택하여 실행

# 실습
[project.ssafy.com](https://project.ssafy.com/home)