# Database

### Database란?
- 데이터베이스(Database): 체계적으로 정리된 데이터의 모음
  - 컴퓨터가 수 많은 정보를 빠르게 찾고, 효율적으로 관리하려면 잘 정리된 책장처럼 데이터를 구조적으로 저장해야 한다.
  - 이 역할을 해주는 것이 바로 DB

### Data란?
- 데이터: 저장이나 처리를 위해 변환된 정보
  - 우리가 표현한 정보를 컴퓨터가 다룰 수 있도록 구조화한 것
  - 분석, 계산, 저장을 위해 정보를 구체적인 형태로 정리한 것

### 증가하는 데이터 사용량
- 배달의 민족: 2022년 한 해 동안 11억 1100만 건 이상의 주문을 처리
- 유튜브: 1분마다 500시간 이상의 새로운 동영상이 업로드
- 넷플릭스: 구독자 3억 명 돌파(2024), 2025년 상반기 동안 전 세계 시청 시간 약 950억 시간
- IBM: 전 세계 모든 데이터의 약 90%는 2015년 이후 생산된 것이라 발표

### 데이터 센터의 성장
- 네이버: 제 2 데이터센터에 6,500억 원을 투자(2020)
- 카카오: 제 1 데이터센터와 제 2 데이터센터에 1.5조 원을 투자(2022)
- 전 세계 데이터 센터 시장은 2024년부터 2029년까지 연 평균 11.13% 성장하여 2029년에는 약 4,386억 8천만 달러 규모에 이를 것으로 예상됨

### 데이터를 저장하고 잘 관리하여 활용할 수 있는 기술이 중요해짐

![1103_SQL_01_2025-11-03-14-20-59](images/1103_SQL_01_2025-11-03-14-20-59.png)

> 우리가 알고 있는 데이터 저장 방식은 어떤 것이 있을까?

### 1. 파일(File) 이용
- 어디에서나 쉽게 사용 가능
- 데이터를 구조적으로 관리하기 어려움

  ![1103_SQL_01_2025-11-03-14-21-41](images/1103_SQL_01_2025-11-03-14-21-41.png)

### 2. 스프레드 시트(Spreadsheet) 이용
- 테이블의 열과 행을 사용해 데이터를 구조적으로 관리 가능

  ![1103_SQL_01_2025-11-03-14-22-07](images/1103_SQL_01_2025-11-03-14-22-07.png)

### 스프레드 시트의 한계
- 크기
  - 일반적으로 약 100만 행까지만 저장가능
- 보안
  - 단순히 파일이나 링크 소유 여부에 따른 단순한 접근 권한 기능 제공
- 정확성
  - 만약 공식적으로 "강원"의 지명이 "강언"으로 바뀌었다고 가정한다면?
  - 이 변경으로 인해 테이블 모든 위치에서 해당 값을 업데이트 해야함
  - 만약 데이터가 여러 시트에 분산되어 있다면 변경에 누락이 생기거나 추가 문제가 발생할 수 있음

### 데이터베이스 역할
- **C**reate **R**ead **U**pdate **D**elete

# Relational Database

## Relational Database란?

### 데이터베이스 역할
- 데이터를 **저장(구조적 저장)** 하고 조작(CRUD)

### Relational Database란?
- 관계형 데이터베이스(Relational Database): 데이터 간에 **관계**가 있는 데이터 항목들의 모음
  - 예: 병원 접수 창구
    - 환자 정보는 한쪽 종이에, 진료 기록은 다른 종이에 적혀 있음
    - 환자 이름이 같은 사람이 여럿이라면, 진료 기록만 보고는 누가 누군지 구별 불가
    - 그래서 병원은 **환자마다 고유한 번호(예: 환자번호)** 를 부여하고, 진료 기록에는 그 번호를 함께 기입
    - 이로 인해 환자 정보와 진료 기록을 정확히 연결할 수 있음

### 관계형 데이터베이스
- 테이블, 행, 열의 정보를 구조화하는 방식
- **서로 관련된 데이터 포인터를 저장**하고 이에 대한 **액세스**를 제공

  ![1103_SQL_01_2025-11-03-14-26-34](images/1103_SQL_01_2025-11-03-14-26-34.png)

### 데이터베이스 역할
- 관계: 여러 테이블 간의 (논리적)연결
  - 데이터를 각각의 테이블에 나눠 저장하되, 공통된 키 값을 통해 서로 연결하여 필요할 때 함께 조회하거나 조작할 수 있도록 함

### 관계로 할 수 있는 것
- 이 관계로 인해 두 테이블을 사용하여 데이터를 다양한 형식으로 조회할 수 있음
  - 특정 날짜에 구매한 모든 고객 조회
  - 지난 달에 배송일이 지연된 고객 조회 등

    ![1103_SQL_01_2025-11-03-14-27-49](images/1103_SQL_01_2025-11-03-14-27-49.png)

### 관계형 데이터베이스 예시
- 다음과 같이 고객 데이터가 테이블에 저장되어 있다고 가정
- 고객 데이터 간 비교를 위해서는 어떤 값을 활용해야 할까?
  > 이름 ? 주소? 만약 동명이인이나 같은 주소지가 있다면?

    ![1103_SQL_01_2025-11-03-14-28-36](images/1103_SQL_01_2025-11-03-14-28-36.png)

  > 각 데이터에 고유한 식별 값을 부여하기 **(기본 키, Primary Key)**

    ![1103_SQL_01_2025-11-03-14-29-07](images/1103_SQL_01_2025-11-03-14-29-07.png)

- 다음과 같이 각 고객이 주문한 주문데이터가 테이블에 저장되어 있다고 가정
- 누가 어떤 주문을 했는지 어떻게 식별할 수 있을까?
  > 고객 이름? 마찬가지로 동명이인이 있다면?

    ![1103_SQL_01_2025-11-03-14-29-59](images/1103_SQL_01_2025-11-03-14-29-59.png)

  > 주문 정보에 고객의 고유한 식별 값을 저장하기 **(외래 키, Foreign Key)**

    ![1103_SQL_01_2025-11-03-14-30-31](images/1103_SQL_01_2025-11-03-14-30-31.png)

### 관계형 데이터베이스 관련 키워드
1. Table (*aka* Relation)
  - 데이터를 기록하는 곳

    ![1103_SQL_01_2025-11-03-14-31-02](images/1103_SQL_01_2025-11-03-14-31-02.png)

2. Field (*aka* Column, Attribute)
  - 각 필드에는 고유한 데이터 형식(타입)이 지정됨

    ![1103_SQL_01_2025-11-03-14-31-34](images/1103_SQL_01_2025-11-03-14-31-34.png)

3. Record (*aka* Row, Tuple)
  - 각 레코드에는 구체적인 데이터 값이 저장됨

    ![1103_SQL_01_2025-11-03-14-32-00](images/1103_SQL_01_2025-11-03-14-32-00.png)

4. Database (*aka* Schema)
  - 테이블의 집합

    ![1103_SQL_01_2025-11-03-14-32-26](images/1103_SQL_01_2025-11-03-14-32-26.png)

5. Primary Key (기본 키, PK)
  - 각 레코드의 고유한 값
  - 관계형 데이터베이스에서 **레코드의 식별자**로 활용

    ![1103_SQL_01_2025-11-03-14-32-57](images/1103_SQL_01_2025-11-03-14-32-57.png)

6. Foreign Key (외래 키, FK)
  - 테이블의 필드 중 다른 테이블의 레코드를 식별할 수 있는 키
  - 다른 테이블의 기본 키를 참조
  - 각 레코드에서 서로 다른 테이블 간의 **관계를 만드는 데** 사용

    ![1103_SQL_01_2025-11-03-14-33-41](images/1103_SQL_01_2025-11-03-14-33-41.png)

## RDBMS

### DBMS란?
- DBMS(Database Management System): 데이터베이스를 관리하는 소프트웨어 프로그램
  - DBMS는 컴퓨터 안에서 '정리된 서류함 역할'
    - 데이터를 일정한 규칙으로 저장
    - 필요할 때 쉽게 꺼내거나 바꿀 수 있도록 도와주는 도구

### DBMS
- 데이터 저장 및 관리를 용이하게 하는 시스템
- DB와 사용자 간의 인터페이스 역할
- 사용자가 데이터 구성, 업데이트, 모니터링, 백업, 복구 등을 할 수 있도록 도움

### RDBMS란?
- RDBMS(Relational Database Management System): 관계형 데이터베이스 관리 소프트웨어 프로그램
  - 예: 도서관의 대출 시스템
    - 책은 도서 목록, 사람은 회원 명단, 대출 내역은 대출 기록이라는 표로 관리된다고 가정
    - 이 세 표는 각각 따로 있지만, 회원 번호와 책 번호를 통해 서로 연결됨
    - RDBMS는 이런 식으로 데이터를 여러 테이블에 나누어 저장하되, 공통된 키를 통해 서로 '관계'를 맺고 함께 사용할 수 있게 해주는 시스템

### RDBMS 서비스 종류
- SQLite
- MySQL
- PostgreSQL
- Oracle Database
- ...
  - 프로젝트의 목적과 환경에 따라 RDBMS를 선택
  - RDBMS는 모두 SQL을 기반으로 동작하지만, 세부 기능이나 사용 방식은 조금씩 다르니 프로젝트에 맞는 도구를 고르는 것이 중요

### SQLite
- 경량의 오픈 소스 DB 관리 시스템
- 설치 없이 가볍게 실행 가능해 모바일 앱이나 소규모 프로그램에 적합
> 컴퓨터나 모바일 기기에 내장되어 간단하고 효율적인 데이터 저장 및 관리를 제공

  ![1103_SQL_01_2025-11-03-14-40-01](images/1103_SQL_01_2025-11-03-14-40-01.png)

### DB 정리
- Table은 데이터가 기록되는 곳
- Table에는 행에서 고유하게 식별 가능한 기본 키라는 속성이 있으며, 외래 키를 사용하여 각 행에서 서로 다른 테이블 간의 관계를 만들 수 있음
- 데이터는 기본 키 또는 외래 키를 통해 결합(join)될 수 있는 여러 테이블에 걸쳐 구조화 됨

# SQL

### SQL이란?
- SQL(Structure Query Language): 테이블의 형태로 **구조화**된 관계형 DB에게 요청을 **질의(요청)**
  - SQL은 DB라는 거대한 도서관에서 '사서' 역할을 하는 DBMS에게 내가 원하는 데이터를 찾아달라고 요청하는 **표준화된 요청서 양식**과 같음
  - "2000년 이후에 출판된 과학 소설 중에서, 책 제목과 저자 정보를 최신순으로 정렬해서 찾아주세요."
  - SQL은 사람이 사용하는 모호한 말이 아닌 **명확하게 약속된 형식**에 따라 DB에 정확한 요청을 전달하는 언어

### SQL Syntax

```SQL
SELECT column_name FROM tabel_name;
```

1. SQL 키워드는 대소문자를 구분하지 않음
  - 하지만 대문자로 작성하는 것을 권장 (명시적 구분)
2. 각 SQL Statements의 끝에는 세미콜론(';')이 필요
  - 세미콜론은 각 SQL Statements을 구분하는 방법 (명령어의 마침표)

## SQL Statements

### SQL Statements
- SQL을 구성하는 가장 기본적인 코드 블록

### SQL Statements 예시

```sql
SELECT column_name FROM table_name;
```

- 해당 예시 코드는 SELECT Statements라 부름
- Statement는 SELECT, FROM 2개의 keyword로 구성

### 수행 목적에 따른 SQL Statements 4가지 유형
1. DDL: 데이터 정의
2. DQL: 데이터 검색
3. DML: 데이터 조작
4. DCL: 데이터 제어

### 수행 목적에 따른 SQL Statements 4가지 유형
- 단순히 SQL 문법을 암기하고 실행만 하는 것이 아닌 관계형 데이터베이스를 잘 이해하고 다루는 방법을 학습

  ![1103_SQL_01_2025-11-03-14-50-20](images/1103_SQL_01_2025-11-03-14-50-20.png)

# Querying data

## 사전 준비

### DB 연결
- VSCode 확장 툴 Database Client 사용
- 사전에 제공한 **sample.sqlite3** DB 연결
- 연결 방법은 공용 노션 문서 참고

  ![1103_SQL_01_2025-11-03-14-51-09](images/1103_SQL_01_2025-11-03-14-51-09.png)

  ![1103_SQL_01_2025-11-03-14-51-17](images/1103_SQL_01_2025-11-03-14-51-17.png)

## DQL

### SQL Statements 유형

![1103_SQL_01_2025-11-03-14-51-41](images/1103_SQL_01_2025-11-03-14-51-41.png)

## SELECT

### <u>SELECT</u> syntax

```sql
SELECT
  select_list
FROM
  table_name;
```

- SELECT 키워드 이후 데이터를 선택하려는 필드를 하나 이상 지정
- FROM 키워드 이후 데이터를 선택하려는 테이블의 이름을 지정

---
- SELECT statement: 테이블에서 데이터를 조회

### SELECT 활용 1
- 테이블 employees에서 LastName 필드의 모든 데이터를 조회

  ![1103_SQL_01_2025-11-03-14-53-37](images/1103_SQL_01_2025-11-03-14-53-37.png)

  ![1103_SQL_01_2025-11-03-14-53-46](images/1103_SQL_01_2025-11-03-14-53-46.png)

### SELECT 활용 2
- 테이블 employees에서 LastName, FirstName 필드의 모든 데이터를 조회

  ![1103_SQL_01_2025-11-03-14-54-22](images/1103_SQL_01_2025-11-03-14-54-22.png)

  ![1103_SQL_01_2025-11-03-14-56-46](images/1103_SQL_01_2025-11-03-14-56-46.png)

### SELECT 활용 3
- 테이블 employees에서 모든 필드 데이터를 조회

  ![1103_SQL_01_2025-11-03-14-57-25](images/1103_SQL_01_2025-11-03-14-57-25.png)

  ![1103_SQL_01_2025-11-03-14-57-56](images/1103_SQL_01_2025-11-03-14-57-56.png)

### SELECT 활용 4
- 테이블 employees에서 FirstName 필드의 모든 데이터를 조회
  - 단, 조회 시 FirstName이 아닌 '이름'으로 출력될 수 있도록 변경

    ![1103_SQL_01_2025-11-03-14-58-42](images/1103_SQL_01_2025-11-03-14-58-42.png)

    ![1103_SQL_01_2025-11-03-14-59-29](images/1103_SQL_01_2025-11-03-14-59-29.png)

### SELECT 활용 5
- 테이블 tracks에서 Name, Milliseconds 필드의 모든 데이터 조회
  - 단, Milliseconds 필드는 60,000으로 나눠 분 단위 값으로 출력

    ![1103_SQL_01_2025-11-03-15-00-15](images/1103_SQL_01_2025-11-03-15-00-15.png)

    ![1103_SQL_01_2025-11-03-15-01-12](images/1103_SQL_01_2025-11-03-15-01-12.png)

### SELECT 정리
- 테이블의 데이터를 조회 및 반환
- '*' (asterisk)를 사용하여 모든 필드 선택

# Sorting data

## ORDER BY

### <u>ORDER BY</u> syntax

```sql
SELECT
  select_list
FROM
  table_name
ORDER BY
  column1 [ASC|DESC],
  column2 [ASC|DESC],
  ...;
```

- FROM clause 뒤에 위치
- 하나 이상의 컬럼을 기준으로 결과를 오름차순(ASC, 기본 값), 내림차순(DESC)으로 정렬

---
- ORDER BY statement: 조회 결과의 레코드를 정렬

### ORDER BY 활용 1
- 테이블 employees에서 FirstName 필드의 모든 데이터를 오름차순으로 조회

  ![1103_SQL_01_2025-11-03-15-16-28](images/1103_SQL_01_2025-11-03-15-16-28.png)

  ![1103_SQL_01_2025-11-03-15-16-39](images/1103_SQL_01_2025-11-03-15-16-39.png)

### ORDER BY 활용 2
- 테이블 employees에서 FirstName 필드의 모든 데이터를 내림차순으로 조회

  ![1103_SQL_01_2025-11-03-15-17-14](images/1103_SQL_01_2025-11-03-15-17-14.png)

  ![1103_SQL_01_2025-11-03-15-17-22](images/1103_SQL_01_2025-11-03-15-17-22.png)

### ORDER BY 활용 3
- 테이블 customers에서 Country 필드를 기준으로 내림차순 정렬한 다음 City 필드 기준으로 오름차순 정렬하여 조회

  ![1103_SQL_01_2025-11-03-15-18-57](images/1103_SQL_01_2025-11-03-15-18-57.png)

  ![1103_SQL_01_2025-11-03-15-19-07](images/1103_SQL_01_2025-11-03-15-19-07.png)

### ORDER BY 활용 4
- 테이블 tracks에서 Milliseconds 필드를 기준으로 내림차순 정렬한 다음 Name, Milliseconds 필드의 모든 데이터를 조회
  - 단, Milliseconds 필드는 60,000으로 나눠 분 단위 값으로 출력

    ![1103_SQL_01_2025-11-03-15-20-12](images/1103_SQL_01_2025-11-03-15-20-12.png)

    ![1103_SQL_01_2025-11-03-15-20-20](images/1103_SQL_01_2025-11-03-15-20-20.png)

### 정렬에서의 NULL
- NULL 값이 존재할 경우 오름차순 정렬 시 결과에 NULL이 먼저 출력

  ![1103_SQL_01_2025-11-03-15-22-53](images/1103_SQL_01_2025-11-03-15-22-53.png)

### SELECT statement 실행 순서

![1103_SQL_01_2025-11-03-15-23-07](images/1103_SQL_01_2025-11-03-15-23-07.png)

1. 테이블에서 (FROM)
2. 조회하여 (SELECT)
3. 정렬 (ORDER BY)

# Filtering data

### Filtering data 관련 Keywords
- <u>Clause</u>
  - **DISTINCT**
  - **WHERE**
  - **LIMIT**
- <u>Operator</u>
  - **BETWEEN**
  - **IN**
  - **LIKE**
  - Comparison
  - Logical

---
- Clause: SQL 문장에서 특정 기능을 수행하도록 지정하는 문장 구성 요소
- Operator: SQL에서 조건을 비교하거나 데이터를 선택하기 위해 사용하는 명령 기호 또는 키워드

## DISTINCT

### <u>DISTINCT</u> syntax

```sql
SELECT DISTINCT
  select_list
FROM
  table_name;
```

- SELECT 키워드 바로 뒤에 작성해야 함
- SELECT DISTINCT 키워드 다음에 고유한 값을 선택하려는 하나 이상의 필드를 지정

---
- DISTINCT statement: 조회 결과에서 중복된 레코드를 제거

### DISTINCT 활용 전
- 테이블 customers에서 Country 필드의 모든 데이터를 오름차순 조회

  ![1103_SQL_01_2025-11-03-15-28-25](images/1103_SQL_01_2025-11-03-15-28-25.png)

  ![1103_SQL_01_2025-11-03-15-29-10](images/1103_SQL_01_2025-11-03-15-29-10.png)

### DISTINCT 활용 1
- 테이블 customers에서 Country 필드의 모든 데이터를 중복없이 오름차순 조회

  ![1103_SQL_01_2025-11-03-15-29-44](images/1103_SQL_01_2025-11-03-15-29-44.png)

  ![1103_SQL_01_2025-11-03-15-29-55](images/1103_SQL_01_2025-11-03-15-29-55.png)

## WHERE

### <u>WHERE</u> syntax

```sql
SELECT
  select_list
FROM
  table_name
WHERE
  search_condition;
```

- FROM clause 뒤에 위치
- search_condition은 비교연산자 및 논리연산자(AND, OR, NOT 등)를 사용하는 구문이 사용됨

---
- WHERE statement: 조회 시 특정 검색 조건을 지정

### WHERE 활용 1
- 테이블 customers에서 City 필드 값이 'Prague'인 데이터의 LastName, FirstName, City 조회

  ![1103_SQL_01_2025-11-03-15-31-57](images/1103_SQL_01_2025-11-03-15-31-57.png)

  ![1103_SQL_01_2025-11-03-15-32-06](images/1103_SQL_01_2025-11-03-15-32-06.png)

### WHERE 활용 2
- 테이블 customers에서 City 필드 값이 'Prague'가 아닌 데이터의 LastName, FirstName, City 조회

  ![1103_SQL_01_2025-11-03-15-33-26](images/1103_SQL_01_2025-11-03-15-33-26.png)

  ![1103_SQL_01_2025-11-03-15-33-35](images/1103_SQL_01_2025-11-03-15-33-35.png)

### WHERE 활용 3
- 테이블 customers에서 Company 필드 값이 NULL이고 Country 필드 값이 'USA'인 데이터의 LastName, FirstName, Company, Country 조회

  ![1103_SQL_01_2025-11-03-15-35-03](images/1103_SQL_01_2025-11-03-15-35-03.png)

  ![1103_SQL_01_2025-11-03-15-36-29](images/1103_SQL_01_2025-11-03-15-36-29.png)

### WHERE 활용 4
- 테이블 customers에서 Company 필드 값이 NULL이거나 Country 필드 값이 'USA'인 데이터의 LastName, FirstName, Company, Country 조회

  ![1103_SQL_01_2025-11-03-15-37-21](images/1103_SQL_01_2025-11-03-15-37-21.png)

  ![1103_SQL_01_2025-11-03-15-37-58](images/1103_SQL_01_2025-11-03-15-37-58.png)

### WHERE 활용 5
- 테이블 tracks에서 Bytes 필드 값이 10,000 이상 500,000 이하인 데이터의 Name, Bytes 조회

  ![1103_SQL_01_2025-11-03-15-38-36](images/1103_SQL_01_2025-11-03-15-38-36.png)

  ![1103_SQL_01_2025-11-03-15-38-47](images/1103_SQL_01_2025-11-03-15-38-47.png)

### WHERE 활용 6
- 테이블 tracks에서 Bytes 필드 값이 10,000 이상 500,000 이하인 데이터의 Name, Bytes를 Bytes 기준으로 오름차순 조회

  ![1103_SQL_01_2025-11-03-15-42-15](images/1103_SQL_01_2025-11-03-15-42-15.png)

  ![1103_SQL_01_2025-11-03-15-42-27](images/1103_SQL_01_2025-11-03-15-42-27.png)

### WHERE 활용 7
- 테이블 customers에서 Country 필드 값이 'Canada' 또는 'Germany' 또는 'France'인 데이터의 LastName, FirstName, Country 조회

  ![1103_SQL_01_2025-11-03-15-43-15](images/1103_SQL_01_2025-11-03-15-43-15.png)

  ![1103_SQL_01_2025-11-03-15-43-23](images/1103_SQL_01_2025-11-03-15-43-23.png)

### WHERE 활용 8
- 테이블 customers에서 Country 필드 값이 'Canada' 또는 'Germany' 또는 'France'가 아닌 데이터의 LastName, FirstName, Country 조회

  ![1103_SQL_01_2025-11-03-15-45-14](images/1103_SQL_01_2025-11-03-15-45-14.png)

  ![1103_SQL_01_2025-11-03-15-45-22](images/1103_SQL_01_2025-11-03-15-45-22.png)

### WHERE 활용 9
- 테이블 customers에서 LastName 필드 값이 'son'으로 끝나는 데이터의 LastName, FirstName 조회

  ![1103_SQL_01_2025-11-03-15-46-14](images/1103_SQL_01_2025-11-03-15-46-14.png)

  ![1103_SQL_01_2025-11-03-15-46-25](images/1103_SQL_01_2025-11-03-15-46-25.png)

### WHERE 활용 10
- 테이블 customers에서 FirstName 필드 값이 4자리면서 'a'로 끝나는 데이터의 LastName, FirstName 조회

  ![1103_SQL_01_2025-11-03-15-48-30](images/1103_SQL_01_2025-11-03-15-48-30.png)

  ![1103_SQL_01_2025-11-03-15-48-39](images/1103_SQL_01_2025-11-03-15-48-39.png)

## Operators

### Comparison Operators
- 비교 연산자
  - =, >=, <=, !=
  - IS, <u>LIKE</u>, <u>IN</u>
  - BETWEEN...AND

### Logical Operators
- 논리 연산자
  - AND(&&)
  - OR(||)
  - NOT(!)

---
- IN Operator: 값이 특정 목록 안에 있는지 확인
- LIKE Operator: 값이 특정 패턴에 일치하는지 확인(Wildcards와 함께 사용)

### Wildcard
- Wildcard Characters
  - '%': **0개 이상의 문자열**과 일치하는지 확인
  - '_': **단일 문자**와 일치하는지 확인

## LIMIT

### <u>LIMIT</u> syntax

```sql
SELECT
  select_list
FROM
  table_name
LIMIT [offset,] row_count;
```

- 하나 또는 두 개의 인자를 사용 (0 또는 양의 정수)
- row_count는 조회하는 최대 레코드 수를 지정

---
- LIMIT statement: 조회하는 레코드 수를 제한

### LIMIT & OFFSET 예시

```sql
SELECT
  ..
FROM
  ..
LIMIT 2, 5;
```

![1103_SQL_01_2025-11-03-15-54-23](images/1103_SQL_01_2025-11-03-15-54-23.png)

### LIMIT 활용 1
- 테이블 tracks에서 TrackId, Name, Bytes 필드 데이터를 Bytes 기준 내림차순으로 7개만 조회

  ![1103_SQL_01_2025-11-03-15-54-59](images/1103_SQL_01_2025-11-03-15-54-59.png)

  ![1103_SQL_01_2025-11-03-15-57-23](images/1103_SQL_01_2025-11-03-15-57-23.png)

### LIMIT 활용 2
- 테이블 tracks에서 TrackId, Name, Bytes 필드 데이터를 Bytes 기준 내림차순으로 4번째부터 7번째 데이터만 조회

  ![1103_SQL_01_2025-11-03-15-58-09](images/1103_SQL_01_2025-11-03-15-58-09.png)

  ![1103_SQL_01_2025-11-03-15-59-27](images/1103_SQL_01_2025-11-03-15-59-27.png)

# Grouping data

## GROUP BY

### <u>GROUP BY</u> syntax

```sql
SELECT
  c1, c2, ..., cn, aggregate_function(ci)
FROM
  table_name
GROUP BY
  c1, c2, ..., cn;
```

- FROM 및 WHERE 절 뒤에 배치
- GROUP BY 절 뒤에 그룹화 할 필드 목록을 작성

---
- GROUP BY statement: 레코드를 그룹화하여 요약본 생성 ('집계 함수'와 함께 사용)

### 집계 함수
- Aggregation Functions(집계 함수): 값에 대한 계산을 수행하고 단일한 값을 반환하는 함수
  - SUM, AVG, MAX, MIN, COUNT

### GROUP BY 예시
1. Country 필드를 그룹화

  ![1103_SQL_01_2025-11-03-16-02-54](images/1103_SQL_01_2025-11-03-16-02-54.png)

2. COUNT 함수는 그룹별로 묶은 총 수를 반환

  ![1103_SQL_01_2025-11-03-16-03-10](images/1103_SQL_01_2025-11-03-16-03-10.png)

### GROUP BY 활용 1
- 테이블 tracks에서 Composer 필드를 그룹화하여 각 그룹에 대한 Bytes의 평균 값을 내림차순 조회

  ![1103_SQL_01_2025-11-03-16-03-46](images/1103_SQL_01_2025-11-03-16-03-46.png)

  ![1103_SQL_01_2025-11-03-16-03-58](images/1103_SQL_01_2025-11-03-16-03-58.png)

  ![1103_SQL_01_2025-11-03-16-04-08](images/1103_SQL_01_2025-11-03-16-04-08.png)

### GROUP BY 활용 2
- 테이블 tracks에서 Composer 필드를 그룹화하여 각 그룹에 대한 Milliseconds의 평균 값이 10 미만인 데이터 조회
  - 단, Milliseconds 필드는 60,000으로 나눠 분 단위 값의 평균으로 계산

    ![1103_SQL_01_2025-11-03-16-07-12](images/1103_SQL_01_2025-11-03-16-07-12.png)

## HAVING

### HAVING
- HAVING clause: 집계 항목에 대한 세부 조건을 지정
  - 주로 GROUP BY와 함께 사용되며 GROUP BY가 없다면 WHERE 처럼 동작

### WHERE와 HAVING 비교

![1103_SQL_01_2025-11-03-16-10-37](images/1103_SQL_01_2025-11-03-16-10-37.png)

![1103_SQL_01_2025-11-03-16-10-52](images/1103_SQL_01_2025-11-03-16-10-52.png)

### SELECT statement 실행 순서

![1103_SQL_01_2025-11-03-16-11-11](images/1103_SQL_01_2025-11-03-16-11-11.png)

1. 테이블에서 (FROM)
2. 특정 조건에 맞추어 (WHERE)
3. 그룹화 하고 (GROUP BY)
4. 만약 그룹 중에서 조건이 있다면 맞추고 (HAVING)
5. 조회하여 (SELECT)
6. 정렬하고 (ORDER BY)
7. 특정 위치의 값을 가져옴 (LIMIT)

# 참고

## Query

### Query란?
- "DB로부터 정보를 요청" 하는 것
- 일반적으로 SQL로 작성하는 코드를 쿼리문(SQL문)이라 함

## NULL 비교

### NULL
- SQL에서 NULL은 실제 값이 아니라 "값이 없음" 또는 "알 수 없음"을 의미
  - 때문에 일반적인 등호('=') 연산자로 NULL을 비교하면 의도한 대로 작동하지 않음

### SQL의 3값 논리
- SQL은 논리 연산에 대해 세 가지 값을 사용
  1. TRUE
  2. FALSE
  3. UNKNOWN (알 수 없음)
- 예를 들어, 'NULL = NULL'의 결과는 TRUE가 아니라 'UNKNOWN'이 됨
- 이는 두 NULL이 실제로 어떤 값을 가지고 있지 않기 때문

### 값의 부재와 불확실성
- NULL은 "값이 존재하지 않음"을 나타내므로, 특정 값과 동일하다고 볼 수 있음
- '=' 연산자를 사용하면, NULL은 어떤 값과도 비교할 수 없으므로 결과가 UNKNOWN이 되어 기대한 결과를 얻지 못함

### 명시적 비교: IS와 IS NOT
- SQL 표준은 NULL 값을 비교할 때 명시적으로 IS NULL 또는 IS NOT NULL 구문을 사용하도록 규정
- WHERE column IS NULL은 해당 컬럼에 값이 없음을 정확하게 확인할 수 있도록 해줌
- 반대로 WHERE column IS NOT NULL은 값이 존재하는 행을 찾음

### = 와 IS 비교

![1103_SQL_01_2025-11-03-16-17-30](images/1103_SQL_01_2025-11-03-16-17-30.png)

## SQL 표준

### SQL 표준
- SQL은 미국 국립 표준 협회(ANSI)와 국제 표준화 기구(ISO)에 의해 표준이 채택됨
- 모든 RDBMS에서 SQL 표준을 지원
- 다만 각 RDBMS마다 독자적인 기능에 따라 표준을 벗어나는 문법이 존재하니 주의

### 실습
- Querying data
  - 1888. SQL 조회 - 기초
  - 2899. 회원 목록 DB - 조회
- Filtering data
  - 2900. 회원 목록 DB - 데이터 정렬과 중복제거
  - 2901. 회원 목록 DB - WildCards
  - 2903. 회원 목록 DB - 조건부 조회 심사
- Sorting data
  - 3050. SQL조회, 정렬
  - 2900. 회원 목록 DB - 데이터 정렬과 중복제거
- Grouping data
  - 1889. SQL 조회 - 심화
  - 3051. SQL 그룹화 조회 - songs
  - 2902. 회원 목록 DB - 집계
