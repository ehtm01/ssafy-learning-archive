# Branch

## 개요

### Branch
- Git Branch: 나뭇가지처럼 여러 갈래로 작업 공간을 나누어 독립적으로 작업할 수 있도록 도와주는 Git의 도구

  ![1107_PJT_06_2025-11-07-09-05-59](images/1107_PJT_06_2025-11-07-09-05-59.png)

### Branch 장점
1. 독립된 개발 환경을 형성하기 때문에 원본(master)에 대해 안전
2. 하나의 작업은 하나의 브랜치로 나누어 진행되므로 체계적으로 협업과 개발이 가능
3. 손쉽게 브랜치를 생성하고 브랜치 사이를 이동할 수 있음

### Branch를 꼭 사용해야 할까?
- 만약 상용 중인 서비스에 발생한 에러를 해결하려면?
  1. 브랜치를 통해 별도의 작업 공간을 만든다.
  2. 브랜치에서 에러가 발생한 버전을 이전 버전으로 되돌리거나 삭제한다.
  3. 브랜치는 완전하게 독립되어 있어서 작업 내용이 master 브랜치에 아무런 영향을 끼치지 못 한다.
  4. 이후 에러가 해결됐다면? 그 내용을 master 브랜치에 반영할 수 있다.

### Master(main) 브랜치의 의미와 역할
- 기본 브랜치 (Default Branch)
  - 저장소의 초기 상태를 나타내며, 일반적으로 프로젝트의 가장 최신 버전 또는 배포 가능한 안정적인 코드를 포함
- 기준점
  - 다른 브랜치가 파생되는 기준점으로 사용됨
- 변경사항 통합
  - 다른 브랜치에서 작업한 기능이나 버그 수정을 완료한 후, 코드 리뷰와 테스트를 거쳐 master(또는 main) 브랜치에 병합

## Branch Command

### git branch
- 브랜치 조회, 생성, 삭제 등 브랜치와 관련된 git 명령어

  ![1107_PJT_06_2025-11-07-09-10-01](images/1107_PJT_06_2025-11-07-09-10-01.png)

### git switch
- 현재 브랜치에서 다른 브랜치로 **HEAD**를 이동시키는 명령어

  ![1107_PJT_06_2025-11-07-09-10-42](images/1107_PJT_06_2025-11-07-09-10-42.png)

### HEAD
- HEAD: 현재 브랜치나 commit을 가리키는 포인터 (현재 내가 바라보는 위치)

### git switch 주의사항
- "git switch 하기 전에, Working Directory 파일이 모두 버전 관리가 되고 있는지 반드시 확인해야 한다."
- 상황 예시
  1. master 브랜치와 feature 브랜치가 존재
  2. feature 브랜치에서 'article.txt'를 생성
  3. **git add** 하지 않고 **git switch master** 실행

    ![1107_PJT_06_2025-11-07-09-13-02](images/1107_PJT_06_2025-11-07-09-13-02.png)

- 상황 결과
  > feature 브랜치에서 생성한 article.txt가 master 브랜치에도 존재하게 됨
1. Git의 브랜치는 독립적인 작업 공간을 갖지만, Git이 관리하는 파일 트리에 제한됨
2. **git add**를 하지 않았던, 즉 Staging area 에 한 번도 올라가지 않은 새 파일은 Git의 버전 관리를 받고 있지 않기 때문에 브랜치가 바뀌더라도 계속 유지
3. 그렇기 때문에 **git switch**를 하기 전, working directory의 모든 파일이 버전 관리 중인지 확인이 필요

# Branch Scenario

## 사전 준비

### 사전 준비
1. git-branch-practice 폴더 생성
2. 생성한 폴더로 이동
3. VSCode 실행
4. Git 저장소 생성

  ![1107_PJT_06_2025-11-07-09-15-52](images/1107_PJT_06_2025-11-07-09-15-52.png)

1. article.txt 생성
2. 각각 master-1, master-2, master-3 이라는 내용을 순서대로 입력하여 commit 3개를 작성

  ![1107_PJT_06_2025-11-07-09-16-26](images/1107_PJT_06_2025-11-07-09-16-26.png)

- master 브랜치의 commit 목록 확인

  ![1107_PJT_06_2025-11-07-09-16-52](images/1107_PJT_06_2025-11-07-09-16-52.png)

- 결과

![1107_PJT_06_2025-11-07-09-17-45](images/1107_PJT_06_2025-11-07-09-17-45.png)

### commit 진행 방향과 화살표 표기 방향이 다른 이유
- commit은 이전 commit 이후에 변경사항만을 기록한 것
- 즉, **이전 commit에 종속되어 생성**됨
- 일반적으로 화살표 방향을 이전 commit을 가리키도록 표기

## Branch 생성 및 조회

### Branch 생성 및 조회
- 현재 위치(master 브랜치의 최신 commit)에서 login 브랜치를 생성
- login 브랜치 생성 확인

  ![1107_PJT_06_2025-11-07-09-20-31](images/1107_PJT_06_2025-11-07-09-20-31.png)

- commit 기준으로 master와 login 브랜치가 위치한 것을 확인

  ![1107_PJT_06_2025-11-07-09-20-56](images/1107_PJT_06_2025-11-07-09-20-56.png)

- master 브랜치에서 commit을 1개 더 작성
- 현재 브랜치와 commit의 상태 확인

  ![1107_PJT_06_2025-11-07-09-21-51](images/1107_PJT_06_2025-11-07-09-21-51.png)

### 결과

![1107_PJT_06_2025-11-07-09-23-11](images/1107_PJT_06_2025-11-07-09-23-11.png)

## Branch 이동
- 현재 브랜치와 commit의 상태 확인
  > 이 때 login 브랜치로 이동하면 article.txt에 어떤 일이 일어날까?

    ![1107_PJT_06_2025-11-07-09-23-57](images/1107_PJT_06_2025-11-07-09-23-57.png)

- master 브랜치에서 article.txt에 작성한 master-4가 사라짐

  ![1107_PJT_06_2025-11-07-09-24-25](images/1107_PJT_06_2025-11-07-09-24-25.png)

- 이제 HEAD는 login 브랜치를 가리키고, master 브랜치가 보이지 않음
- master 브랜치는 삭제된 걸까?
  > HEAD가 login 브랜치를 가리키면서, log도 login 기준으로 보이는 것

    ![1107_PJT_06_2025-11-07-09-25-08](images/1107_PJT_06_2025-11-07-09-25-08.png)

- --all 옵션을 사용하면 모든 브랜치의 log를 확인 가능

  ![1107_PJT_06_2025-11-07-09-25-34](images/1107_PJT_06_2025-11-07-09-25-34.png)

### 결과

![1107_PJT_06_2025-11-07-09-25-48](images/1107_PJT_06_2025-11-07-09-25-48.png)

## Branch에서 commit 생성

### Branch에서 commit 생성
- login 브랜치에서 article.txt 파일 수정
- article.txt 파일에 login-1 작성

  ![1107_PJT_06_2025-11-07-09-26-29](images/1107_PJT_06_2025-11-07-09-26-29.png)

- 추가적으로 test_login.txt도 생성하고 login-1이라고 작성
- commit 생성

  ![1107_PJT_06_2025-11-07-09-27-17](images/1107_PJT_06_2025-11-07-09-27-17.png)

- --graph 옵션을 활용해 전채 commit 목록 확인
- master 브랜치와 login 브랜치가 다른 갈래로 갈라진 것을 확인

  ![1107_PJT_06_2025-11-07-09-27-59](images/1107_PJT_06_2025-11-07-09-27-59.png)

### 결과

![1107_PJT_06_2025-11-07-09-28-18](images/1107_PJT_06_2025-11-07-09-28-18.png)

### git branch 정리
- 브랜치의 이동은 HEAD가 특정 브랜치를 가리킨다는 것
- 브랜치는 가장 최신 commit을 가리키므로 HEAD가 해당 브랜치의 최신 commit을 가리킴
- 즉, working directory의 내용도 HEAD가 가리키는 브랜치의 최신 commit 상태로 변화하는 것

# Git Merge

## 개요

### Git Merge
- Git Merge: 두 브랜치를 하나로 병합(결합)
  - https://www.atlassian.com/git/tutorials/using-branches/git-merge

  ![1107_PJT_06_2025-11-07-09-35-21](images/1107_PJT_06_2025-11-07-09-35-21.png)

- merge 명령어: git merge <병합 브랜치 이름>

### 병합 전 확인 및 주의사항
1. 수신 브랜치(병합 브랜치를 가져오고자 하는 브랜치) 확인하기
  - git branch 명령어를 통해 HEAD가 올바른 수신 브랜치를 가리키는지 확인
  - 병합 진행 위치는 반드시 수신 브랜치에서 진행되어야 함
2. 최신 commit 상태 확인하기
  - 수신 브랜치와 병합 브랜치 모두 최신 상태인지 확인

### Merge 종류
1. **Fast-Forward** Merge
2. **3-Way** Merge

## Fast-Forward Merge

### Fast-Forward Merge
- Fast-Forward Merge: 브랜치를 "실제로" 병합하는 대신 현재 브랜치 상태를 대상 브랜치 상태로 이동시키는 작업 (빨리 감기)
  > Merge 과정 없이 단순히 브랜치의 포인터가 앞으로 이동

### Fast-Forward 동작 원리

![1107_PJT_06_2025-11-07-09-40-00](images/1107_PJT_06_2025-11-07-09-40-00.png)

### Fast-Forward Merge
1. fast-forward-practice 폴더 생성
2. 생성한 폴더로 이동
3. VSCode 실행
4. Git 저장소 생성

![1107_PJT_06_2025-11-07-09-42-57](images/1107_PJT_06_2025-11-07-09-42-57.png)

![1107_PJT_06_2025-11-07-09-43-30](images/1107_PJT_06_2025-11-07-09-43-30.png)

![1107_PJT_06_2025-11-07-09-43-38](images/1107_PJT_06_2025-11-07-09-43-38.png)

![1107_PJT_06_2025-11-07-09-43-59](images/1107_PJT_06_2025-11-07-09-43-59.png)

![1107_PJT_06_2025-11-07-09-44-24](images/1107_PJT_06_2025-11-07-09-44-24.png)

- 병합 완료된 브랜치는 삭제

  ```bash
  $ git branch -d hotfix
  ```

### 결과

![1107_PJT_06_2025-11-07-09-45-55](images/1107_PJT_06_2025-11-07-09-45-55.png)

## 3-Way Merge

### 3-Way Merge
- 3-Way Merge: 병합하는 각 브랜치의 commit 2개와 공통 조상 commit 하나를 사용하여 병합하는 작업

### 3-Way Merge 동작 원리

![1107_PJT_06_2025-11-07-09-46-35](images/1107_PJT_06_2025-11-07-09-46-35.png)

### 3-Way Merge
1. 3-way-merge-practice 폴더 생성
2. 생성한 폴더로 이동
3. VSCode 실행
4. Git 저장소 생성

![1107_PJT_06_2025-11-07-09-48-29](images/1107_PJT_06_2025-11-07-09-48-29.png)

![1107_PJT_06_2025-11-07-09-49-12](images/1107_PJT_06_2025-11-07-09-49-12.png)

![1107_PJT_06_2025-11-07-09-49-21](images/1107_PJT_06_2025-11-07-09-49-21.png)

![1107_PJT_06_2025-11-07-09-52-29](images/1107_PJT_06_2025-11-07-09-52-29.png)

![1107_PJT_06_2025-11-07-09-52-48](images/1107_PJT_06_2025-11-07-09-52-48.png)

- hotfix 브랜치를 master 브랜치로 병합 진행

  ![1107_PJT_06_2025-11-07-09-53-31](images/1107_PJT_06_2025-11-07-09-53-31.png)

- commit 전체 목록 확인

  ![1107_PJT_06_2025-11-07-09-53-48](images/1107_PJT_06_2025-11-07-09-53-48.png)

- 병합 완료된 브랜치 삭제

  ```bash
  $ git branch -d hotfix
  ```

### 결과

![1107_PJT_06_2025-11-07-09-54-23](images/1107_PJT_06_2025-11-07-09-54-23.png)

## Merge Conflict

### Merge Conflict
- Merge Conflict: 병합하려는 두 브랜치가 "동일한 파일의 동일한 부분"에서 변경된 후 병합 시 충돌이 발생하는 것

### git이 충돌을 표시하는 방식
- 시각적 마커
  - <<<<<<<
  - =======
  - \>>>>>>>
- 일반적으로 ======= 마커, 위의 콘텐츠는 수신, 아래 콘텐츠는 병합 브랜치

  ![1107_PJT_06_2025-11-07-09-56-00](images/1107_PJT_06_2025-11-07-09-56-00.png)

### git 충돌을 해결하는 과정
1. 충돌하는 부분을 확인한 후에는 원하는 대로 충돌 내용을 수정
2. 병합을 완료할 준비가 되면 충돌하는 파일에서 **git add** 명령을 실행
3. 그런 다음 **git commit**을 실행하여 **merge commit**을 생성
> 병합 충돌은 3-Way-merge 인 경우에만 발생

### Merge Conflict
1. merge-conflict-practice 폴더 생성
2. 생성한 폴더로 이동
3. VSCode 실행
4. Git 저장소 실행

![1107_PJT_06_2025-11-07-10-07-20](images/1107_PJT_06_2025-11-07-10-07-20.png)

![1107_PJT_06_2025-11-07-10-07-31](images/1107_PJT_06_2025-11-07-10-07-31.png)

![1107_PJT_06_2025-11-07-10-07-39](images/1107_PJT_06_2025-11-07-10-07-39.png)

![1107_PJT_06_2025-11-07-10-08-01](images/1107_PJT_06_2025-11-07-10-08-01.png)

![1107_PJT_06_2025-11-07-10-10-21](images/1107_PJT_06_2025-11-07-10-10-21.png)

1. master 브랜치로 이동
2. hotfix 브랜치 병합 진행
3. 충돌 확인

  ![1107_PJT_06_2025-11-07-10-10-43](images/1107_PJT_06_2025-11-07-10-10-43.png)

- 충돌 후 VSCode 화면 확인
- 충돌 영역을 원하는 내용으로 변경해야 함

  ![1107_PJT_06_2025-11-07-10-11-20](images/1107_PJT_06_2025-11-07-10-11-20.png)

- git status를 사용해 확인
- 충돌이 일어난 article.txt 파일의 **both modified** 상태 확인

  ![1107_PJT_06_2025-11-07-10-11-57](images/1107_PJT_06_2025-11-07-10-11-57.png)

- article.txt 파일 수정

  ![1107_PJT_06_2025-11-07-10-12-23](images/1107_PJT_06_2025-11-07-10-12-23.png)

- git add 진행 후 status 확인

  ![1107_PJT_06_2025-11-07-10-13-23](images/1107_PJT_06_2025-11-07-10-13-23.png)

- git commit 진행 후 vim 에디터 실행 확인

  ![1107_PJT_06_2025-11-07-10-13-43](images/1107_PJT_06_2025-11-07-10-13-43.png)

- merge commit에 대한 commit 메시지를 작성하기 위한 vim 에디터가 실행되는 것
- 기본적으로 git이 지정한 commit 메시지가 작성되어 있음
- 필요에 따라 commit 메시지를 수정 가능
- 수정 없이 진행하려면 **:wq** 를 입력 후 **enter**를 클릭해 저장 및 종료
- 충돌 해결 후 commit 목록 확인

  ![1107_PJT_06_2025-11-07-10-14-51](images/1107_PJT_06_2025-11-07-10-14-51.png)

- 병합 완료된 브랜치 삭제

  ```bash
  $ git branch -d hotfix
  ```

### 결과

![1107_PJT_06_2025-11-07-10-15-24](images/1107_PJT_06_2025-11-07-10-15-24.png)

# Git Workflow

### Git workflow
- Git workflow: 원격 저장소를 활용해 다른 사용자와 협업하는 방법

## Feature Branch Workflow

### Feature Branch Workflow
- Feature Branch Workflow: Shared repository model (각 사용자가 원격저장소의 소유권을 공유받는 방식)

### "중앙 원본 저장소(Origin)는 하나, 기능 개발은 별도의 브랜치(Branch)에서"
- 모든 팀원이 하나의 중앙 원본 저장소(`Origin`)를 공유
- `master`(또는 `main`) 브랜치는 항상 안정적이고 배포 가능한 상태로 유지됨
- 새로운 기능 개발이나 버그 수정은 반드시 `feature/login`, `fix/header-bug`와 같이 별도의 브랜치를 생성하여 진행
- 작업이 완료되면, 중앙 저장소에 브랜치를 푸시(`push`)하고 **풀 리퀘스트(Pull Request, PR)** 를 통해 코드 리뷰를 거친 뒤 `master` 브랜치에 병합(`merge`)

### 풀 리퀘스트 (Pull Request)란?
- 내가 별도 브랜치(Branch)에서 작업한 새로운 내용을, master와 같은 **원본(또는 대상) 브랜치에 합병(Merge)해 달라고 공식적으로 요청**하는 기능
- 이는 단순한 '코드 합치기 요청'을 넘어, **협업을 위한 핵심 소통 도구**로 사용

### PR의 핵심 목적: 코드 리뷰 (Code Review)
- PR의 진정한 목적은 코드를 합치기 전에, 동료나 프로젝트 관리자(Maintainer)가 변경된 내용을 **검토(Review)하고 피드백을 줄 수 있는** 공식적인 장을 마련하는 것

### 원격 저장소 공유
- 소유권을 가진 사용자가 권한을 공유할 인원을 초대 (Coolaborators)

  ![1107_PJT_06_2025-11-07-10-23-05](images/1107_PJT_06_2025-11-07-10-23-05.png)

### Feature Branch Workflow

![1107_PJT_06_2025-11-07-10-23-26](images/1107_PJT_06_2025-11-07-10-23-26.png)

![1107_PJT_06_2025-11-07-10-23-37](images/1107_PJT_06_2025-11-07-10-23-37.png)

![1107_PJT_06_2025-11-07-10-23-53](images/1107_PJT_06_2025-11-07-10-23-53.png)

![1107_PJT_06_2025-11-07-10-24-01](images/1107_PJT_06_2025-11-07-10-24-01.png)

![1107_PJT_06_2025-11-07-10-24-09](images/1107_PJT_06_2025-11-07-10-24-09.png)

![1107_PJT_06_2025-11-07-10-28-25](images/1107_PJT_06_2025-11-07-10-28-25.png)

![1107_PJT_06_2025-11-07-10-28-33](images/1107_PJT_06_2025-11-07-10-28-33.png)

![1107_PJT_06_2025-11-07-10-28-42](images/1107_PJT_06_2025-11-07-10-28-42.png)

![1107_PJT_06_2025-11-07-10-28-50](images/1107_PJT_06_2025-11-07-10-28-50.png)

![1107_PJT_06_2025-11-07-10-29-00](images/1107_PJT_06_2025-11-07-10-29-00.png)

### Feature Branch Workflow 왜, 언제 사용하는가?
- 목적
  - master 브랜치의 안정성을 확보하고, 여러 기능 개발이 서로 충돌 없이 동시에 진행될 수 있도록 하기 위함
- 사용 시점
  - 신뢰할 수 있는 팀원들(예: 사내 개발팀, 프로젝트 팀)이 하나의 프로젝트를 함께 개발할 때 가장 표준적으로 사용되는 방식

## Git Flow

### Git Flow란 무엇인가?
- 프로젝트를 운영할 때 원활한 협업과 체계적인 버전 관리를 위해 사용하는 **브랜치 관리전략 중 하나**
- 핵심
  - `main`, `develop`, `feature`, `release`, `hotfix`라는 5가지 종류의 브랜치를 각자의 명확한 역할에 따라 운영하는 방식
- 참고
  - 이 전략이 모든 팀에 완벽한 정답은 아님
  - 하지만 협업 프로젝트를 진행할 때 이 구조를 기준으로 삼으면, **충돌(Conflict)을 최소화**하고 **배포(Deploy) 과정을 안정적으로 관리**하는 데 큰 도움이 될 수 있음

### Git Flow 전체 흐름도
- 가장 먼저, 이 그림을 통해 각 브랜치가 **어디에서 시작(분기)되고 어디로 합쳐지는지(병합)** 그 관계를 파악하는 것이 중요
- 크게 `master`와 `develop`이라는 **두 개의 메인 브랜치**와 필요할 때 생성되고 삭제되는 `feature`, `release`, `hotfix` 같은 **보조 브랜치**로 나뉨

  ![1107_PJT_06_2025-11-07-10-51-13](images/1107_PJT_06_2025-11-07-10-51-13.png)

### master(main) branch - "제품 그 자체"
- **실제 프로덕션(운영 서버)에 배포**되는 가장 안정적인 최신 버전의 코드를 관리
  1. 이 브랜치에는 **절대 직접 커밋(commit)하지 않음**
  2. 오직 `release` 브랜치 또는 `hotfix` 브랜치의 내용만 병합(Merge)됨
  3. `master` 브랜치의 모든 커밋은 **"항상 배포 가능한 상태"** 임을 보장해야 함
  4. 각 커밋은 `v1.0`, `v1.1`과 같은 버전 태그(Tag)로 관리하는 것이 좋음

    ![1107_PJT_06_2025-11-07-10-54-06](images/1107_PJT_06_2025-11-07-10-54-06.png)

### develop branch - "다음 배포를 위한 개발 기지"
- **다음 릴리즈 버전을 개발**하기 위한 모든 기능들이 **통합(Intrgration)** 되는 브랜치
  1. `master` 브랜치에서 최초로 생성되며, `master`와는 독립적으로 개발이 진행
  2. 이 브랜치에도 **직접 커밋하지 않는 것을 원칙**으로 함
  3. 모든 `feature` 브랜치들이 개발 완료 후 `develop`으로 병합됨
  4. 배포할 시점이 되면, 이 브랜치에서 `release` 브랜치가 분기됨

    ![1107_PJT_06_2025-11-07-10-55-34](images/1107_PJT_06_2025-11-07-10-55-34.png)

### feature branch - "기능 개발 작업실"
- **하나의 특정 기능**(예: 로그인, 장바구니)을 개발하기 위한 브랜치
  1. 항상 `develop` 브랜치에서 분기(branch)함
  2. 브랜치 이름은 `feature/login`, `feature/cart`처럼 기능을 명시하는 것이 좋음
  3. 개발이 완료되면, **다시 `develop` 브랜치로 병합` (보통 PR을 통해)
  4. `master`나 `release` 브랜치와는 절대 직접 상호작용하지 않음

    ![1107_PJT_06_2025-11-07-10-57-41](images/1107_PJT_06_2025-11-07-10-57-41.png)

- 충돌을 방지하기 위해 병합 전 항상 최신 develop 브랜치의 내용을 받아와(pull) 내 브랜치에 먼저 반영하는 것이 좋음

### release branch - "배포를 위한 최종 점검"
- **이번 버전 배포를 준비**하기 위한 브랜치
- 새로운 기능 개발을 멈추고, 배포 전 최종 테스트와 버그 수정, 버전 번호 업데이트 등만 수행
  1. **`develop` 브랜치에서 분기**
  2. 배포 준비가 완료되면(모든 테스트 통과), **`master` 브랜치로 병합**하여 배포
  3. `release` 브랜치에서 수정한 버그 내용이 `develop` 브랜치에도 반영될 수 있도록 **반드시 `develop` 브랜치에도 다시 병합**해야 함 <mark>(매우 중요)</mark>

    ![1107_PJT_06_2025-11-07-11-02-13](images/1107_PJT_06_2025-11-07-11-02-13.png)

### hotfix branch - "긴급, 프로덕션 버그 수정"
- 이미 배포된 **`master` 브랜치에서 발생한 긴급한 버그**를 즉시 수정하기 위한 브랜치
  1. `develop`이나 `feature`를 기다릴 수 없으므로, **항상 `master` 브랜치에서 직접 분기**
  2. 버그 수정이 완료되면, **즉시 `master` 브랜치로 병합**하여 재배포
  3. 이 버그 수정 내용은 **반드시 `develop` 브랜치에도 병합**하여 다음 릴리즈 버전에 해당 버그가 다시 포함되는 것을 방지해야 함 <mark>(매우 중요)</mark>

    ![1107_PJT_06_2025-11-07-11-02-05](images/1107_PJT_06_2025-11-07-11-02-05.png)

## Forking Workflow

### Forking Workflow
- Forking Workflow: Fork & Pull model (각 사용자가 소유권이 없는 원격저장소를 복제하는 방식)
- Fork: 다른 사용자의 원격 저장소를 자신의 계정으로 복사하는 것

### "내 저장소(Fork)에서 자유롭게 작업하고, 괜찮으면 원본에 제안(PR)하기"
- 중앙 원본 저장소(`Upstream`)에 직접 푸시(`push`)할 수 없음
- 개발자는 먼저 중앙 저장소를 **내 개인 계정으로 그대로 복제(`Fork`)**하여, **완전히 독립된 나만의 원격 저장소(Origin)**를 만듦
- 모든 작업(브랜치 생성, 커밋)은 내 개인 저장소에서 자유롭게 이뤄짐
- 작업이 완료되면, 내 저장소에서 중앙 원본 저장소로 **풀 리퀘스트(PR)**를 보내 "제가 작업한 이 내용을 반영해 주세요"라고 **제안**
- 원본 저장소의 관리자(Maintainer)가 이 제안을 검토하고 승인해야만 원본에 병합됨

### 원격 저장소 복제하며 시작 (fork)
- 소유권이 없는 사용자가 원격 저장소를 본인의 repository 목록으로 복제

  ![1107_PJT_06_2025-11-07-11-16-16](images/1107_PJT_06_2025-11-07-11-16-16.png)

### Forking Workflow

![1107_PJT_06_2025-11-07-11-16-34](images/1107_PJT_06_2025-11-07-11-16-34.png)

![1107_PJT_06_2025-11-07-11-16-42](images/1107_PJT_06_2025-11-07-11-16-42.png)

![1107_PJT_06_2025-11-07-11-16-53](images/1107_PJT_06_2025-11-07-11-16-53.png)

![1107_PJT_06_2025-11-07-11-17-07](images/1107_PJT_06_2025-11-07-11-17-07.png)

![1107_PJT_06_2025-11-07-11-17-18](images/1107_PJT_06_2025-11-07-11-17-18.png)

![1107_PJT_06_2025-11-07-11-17-28](images/1107_PJT_06_2025-11-07-11-17-28.png)

![1107_PJT_06_2025-11-07-11-17-41](images/1107_PJT_06_2025-11-07-11-17-41.png)

![1107_PJT_06_2025-11-07-11-18-20](images/1107_PJT_06_2025-11-07-11-18-20.png)

![1107_PJT_06_2025-11-07-11-18-34](images/1107_PJT_06_2025-11-07-11-18-34.png)

![1107_PJT_06_2025-11-07-11-18-45](images/1107_PJT_06_2025-11-07-11-18-45.png)

### Forking Workflow 왜, 언제 사용하는가?
- 목적
  - 원본 프로젝트의 코드 품질과 안정성을 최고 수준으로 유지하고, 외부 기여자의 코드를 안전하게 검토하기 위함
- 사용 시점
  - **오픈 소스 프로젝트**처럼, 핵심 관리자 그룹 외에 **신뢰할 수 없는 다수의 외부 기여자**가 프로젝트에 참여할 때 사용됨