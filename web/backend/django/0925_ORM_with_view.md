# Read

### 2가지 Read(조회) 진행
1. 전체 게시글 조회
2. 단일 게시글 조회 v

### 단일 게시글 조회
- 최종 결과화면 미리보기

![0925_ORM_with_view_2025-09-25-08-59-08](images/0925_ORM_with_view_2025-09-25-08-59-08.png)

- 단일 게시글 조회 구현

![0925_ORM_with_view_2025-09-25-09-00-37](images/0925_ORM_with_view_2025-09-25-09-00-37.png)

### 단일 게시글 이동 페이지 링크 작성
- 최종 결과화면 미리보기

![0925_ORM_with_view_2025-09-25-09-03-22](images/0925_ORM_with_view_2025-09-25-09-03-22.png)

- 단일 게시글 이동 페이지 링크 구현

![0925_ORM_with_view_2025-09-25-09-03-40](images/0925_ORM_with_view_2025-09-25-09-03-40.png)

# Create
### Create 로직을 구현하기 위해 필요한 view 함수의 개수는?

![0925_ORM_with_view_2025-09-25-09-04-05](images/0925_ORM_with_view_2025-09-25-09-04-05.png)

- Create 로직 구현에는 **두 개의 view 함수**가 필요함

### new - 페이지 렌더링 기능 구현
- 최종 결과화면 미리보기

![0925_ORM_with_view_2025-09-25-09-04-37](images/0925_ORM_with_view_2025-09-25-09-04-37.png)

- 게시글 생성 페이지 구현

![0925_ORM_with_view_2025-09-25-09-05-12](images/0925_ORM_with_view_2025-09-25-09-05-12.png)

- Index 페이지에 new 페이지로 이동할 수 있는 하이퍼링크 작성

![0925_ORM_with_view_2025-09-25-09-05-36](images/0925_ORM_with_view_2025-09-25-09-05-36.png)

### create - 데이터 저장 기능 구현
- 최종 결과화면 미리보기

![0925_ORM_with_view_2025-09-25-09-05-59](images/0925_ORM_with_view_2025-09-25-09-05-59.png)

- 데이터 저장 기능 구현

![0925_ORM_with_view_2025-09-25-09-06-32](images/0925_ORM_with_view_2025-09-25-09-06-32.png)

![0925_ORM_with_view_2025-09-25-09-06-57](images/0925_ORM_with_view_2025-09-25-09-06-57.png)

# HTTP request methods

## HTTP

### HTTP란?
- 네트워크 상에서 **데이터(리소스)** 를 주고 받기위한 약속

### HTTP request methods란?
- 데이터에 대해 수행을 원하는 작업(행동)을 나타내는 것
    - 서버에게 원하는 작업의 종류를 알려주는 역할
- 대표적인 메서드
    - GET
        - 리소스 조회
            - URL에 데이터가 노출됨
            - <u>캐싱</u> 가능
    - POST
        - 데이터 생성/전송
            - 요청 본문에 데이터
            - 데이터 노출 없음

---
- 캐싱: 자주 사용하는 데이터나 결과를 임시로 저장해두고 재활용하여 처리 속도를 높이는 기술

## GET method

### HTTP request methods: GET 메서드
- 서버로부터 데이터를 요청하고 받아오는데 **(조회)** 사용
    - 주로 **검색 쿼리 전송, 웹 페이지 요청**, 그리고 **API에서 데이터를 조회**

### 'GET' Method 특징
1. 데이터 전송
    - URL의 쿼리 문자열(Query String)을 통해 데이터를 전송
    - http://127.0.0.1:8000/articles/create/?title=제목&content=내용
2. 데이터 제한
    - URL 길이에 제한이 있어 대량의 데이터 전송에는 적합하지 않음
3. 브라우저 히스토리
    - 요청 URL이 브라우저 히스토리에 남음
4. 캐싱
    - 브라우저는 GET 요청의 응답을 로컬에 저장할 수 있음
    - 동일한 URL로 다시 요청할 때, 서버에 접속하지 않고 저장된 결과를 사용
    - 페이지 로딩 시간을 크게 단축

## POST method

### POST method란?
- 서버에 데이터를 제출하여 리소스를 **변경(생성, 수정, 삭제)** 하는데 사용
    - 주로 **로그인 정보 제줄, 파일 업로드, 새 데이터 생성**(예: 새 게시글 작성), 그리고 **API에서 데이터 변경을 요청**하는 것과 같이 클라이언트가 **서버로 데이터를 전송하여 서버의 상태를 변경**할 때 사용됨

### 'POST' Method 특징
1. 데이터 전송
    - HTTP Body를 통해 데이터를 전송
2. 데이터 제한
    - GET에 비해 더 많은 양의 데이터를 전송할 수 있음
3. 브라우저 히스토리
    - POST 요청은 브라우저 히스토리에 남지 않음
4. 캐싱
    - POST 요청은 기본적으로 캐시할 수 없음
    - POST 요청이 일반적으로 서버의 상태를 변경하는 작업을 수행하기 때문

### 'GET' & 'POST' Method 정리
- GET과 POST는 각각의 특성에 맞게 적절히 사용해야함
- GET
    - 데이터 조회
- POST
    - 데이터 생성이나 수정에 주로 사용

## Post method 변경

### Create 로직 수정 - "http method POST로 변경"
- new.html의 form 요청은 **새로운 article(새로운 데이터)** 을 생성하는 요청
    - POST method로 서버에 전달되는 것이 적절함

![0925_ORM_with_view_2025-09-25-10-00-04](images/0925_ORM_with_view_2025-09-25-10-00-04.png)

### Create 로직 수정 - "http method 변경 후 게시글 생성 테스트"
- 게시글 작성 후 403 응답 확인

![0925_ORM_with_view_2025-09-25-10-03-17](images/0925_ORM_with_view_2025-09-25-10-03-17.png)

# HTTP response status code

### HTTP response status code란?
- 서버가 클라이언트의 요청에 대한 처리 결과를 나타내는 **3자리 숫자**
    - 클라이언트는 이 코드를 통해 **요청이 성공했는지, 실패했는지, 아니면 추가적인 조치가 필요한지 즉시 파악**할 수 있음
    - 이를 통해 웹 브라우저는 적절한 메시지를 사용자에게 표시하거나, 개발자는 문제 해결을 위한 단서를 알게됨.

### 403 Forbidden 응답의 의미
- 서버에 요청이 전달되었지만, **권한** 때문에 거절되었다는 것을 의미

### 403 Forbidden 응답으로 거절된 이유
- "CSRF token이 누락되었다" 라는 응답

![0925_ORM_with_view_2025-09-25-10-08-37](images/0925_ORM_with_view_2025-09-25-10-08-37.png)

## CSRF

### CSRF란(Cross-Site-Request-Forgery)?
- 사이트 간 요청 위조
- **사용자가 자신의 의지와는 무관하게** 공격자가 의도한 행동(글쓰기, 정보 수정, 송금 등)을 특정 웹사이트에 요청하게 만드는 해킹 방식

### CSRF (위조된 인감도장)
1. 신뢰할 수 있는 관계 (로그인)
    - 사용자는 은행(예: bank.com)에 정상적으로 로그인하여, 은행은 사용자를 신뢰하고 있다는 증표(세션 쿠키)를 브라우저에 발급.
        - 이 쿠키가 바로 당신의 '인감도장'
2. 악성 위임장 (악성 링크)
    - 사기꾼(해커)은 "무료 경품 이벤트!" 와 같은 미끼 링크를 사용자에게 보냄.
    - 이 링크의 실제 내용은 "내 돈 100만원을 해커에게 송금하라" 는 내용이 담긴, 당신의 인감도장만 찍으면 되는 '위조된 위임장'
3. 나도 모르는 날인 (요청 전송)
    - 사용자가 미끼 링크를 클릭하는 순간, 당신의 브라우저는 자기도 모르게 bank.com에 위조된 위임장(송금 요청)을 보냄.
        - 이 때 브라우저는 bank.com에 보낼 때마다 인감도장(세션 쿠키)을 자동으로 찍어서 보냄.
4. 은행의 착각 (공격 성공)
    - 은행 입잡에서는 정상적인 인감도장이 찍힌 위임장이 도착했으므로, 이 요청이 당신의 진짜 의사라고 믿고 송금을 실행.

### CSRF 공격의 방어
- Django는 이러한 공격을 막기 위해 **CSRF 토큰**이라는 안전장치를 사용
- 이는 위임장에 진짜 서명이 있는지 확인하는 것처럼, 모든 중요한 요청에 대해 "내가 직접 보낸 요청이 맞다"는 일회용 비밀 코드를 함께 보내도록 하여 위조된 요청을 막아줌

### CSRF Token 적용
- DTL의 csrf_token 태그를 사용해 손쉽게 사용자에게 토큰 값을 부여
- 요청 시 토큰 값도 함께 서버로 전송될 수 있도록 하는 것

![0925_ORM_with_view_2025-09-25-10-15-33](images/0925_ORM_with_view_2025-09-25-10-15-33.png)

### 요청 시 CSRF Token을 함께 보내야 하는 이유
- Django 서버는 해당 요청이 DB에 데이터를 하나 생성하는(DB에 영향을 주는) 요청에 대해 **"Django가 직접 제공한 페이지에서 데이터를 작성하고 있는 것인지"** 에 대한 확인 수단이 필요한 것
- 겉모습이 똑같은 위조 사이트나 정상적이지 않은 요청에 대한 방어 수단
- 기존 요청 형태
    - 요청 데이터 -> 게시글 작성
- 변경 요청 형태
    - 요청 데이터 **+ 인증 토큰** -> 게시글 작성

### 그런데 왜 POST일 때만 Token을 확인할까?
- POST는 **단순 조회(GET)**와 달리 **리소스의 변경(생성, 수정, 삭제)을 요청**하는 **의미와 기술적 특성**을 지님
- **DB에 조작**을 가하는 요청은 반드시 인증 수단이 필요

> DB에 대한 변경사항을 만드는 요청이기 때문에 토큰을 사용해 최소한의 신원 확인을 하는 것

### 게시글 작성 결과
- 더 이상 URL에 Query String 형태로 보냈던 데이터가 표기되지 않음 (기존 GET method 방식)

    ![0925_ORM_with_view_2025-09-25-10-20-28](images/0925_ORM_with_view_2025-09-25-10-20-28.png)

- 게시글 생성 후 개발자 도구를 사용해 Form Data가 전송되는 것 확인

    ![0925_ORM_with_view_2025-09-25-10-20-49](images/0925_ORM_with_view_2025-09-25-10-20-49.png)

# Redirect

### 현재 문제 상황: 게시글 작성 후 응답 방식
- 현재 서비스는 게시글 작성(POST 요청) 이후, "**게시글이 성공적으로 작성되었습니다**" 와 같은 완료 메시지 페이지를 직접 반환함
- **게시글 저장 후 페이지를 응답하는 것은 POST 요청에 대한 적절한 응답이 아님**
- 이는 후속 행동(예: 새로고침, 뒤로 가기)에서 예기치 않은 동작을 유발할 수 있음

![0925_ORM_with_view_2025-09-25-10-22-12](images/0925_ORM_with_view_2025-09-25-10-22-12.png)

### 게시글 작성 성공 페이지 응답의 문제점
- HTTP 표준 관점
    - POST 요청은 데이터 생성/변경에 사용되며, 동일 요청이 반복되면 안됨
    - 현재 방식에선 사용자가 **완료 페이지에서 새로고침 시 중복 게시물 작성의 위험이 있음**

        ![0925_ORM_with_view_2025-09-25-11-03-17](images/0925_ORM_with_view_2025-09-25-11-03-17.png)

- 사용자 경험(UX) 관점
    - 작성 완료 후 완료 페이지를 직접 응답하는 방식은 **직관적이지 않고**, 사용자가 예상하는 흐름과 다름
    - 브라우저의 페이지 기록 관리와 상태 관리에 혼란을 줄 수 있음

        ![0925_ORM_with_view_2025-09-25-11-04-02](images/0925_ORM_with_view_2025-09-25-11-04-02.png)

### 게시글 작성 성공 후 적절한 응답 방법
- 서버는 데이터 저장 후 페이지를 응답하는 것이 아닌 사용자를 적절한 기존 페이지로 보내야 한다.
    - "사용자를 보낸다." -> "사용자가 GET 요청을 한 번 더 보내도록 해야 한다."
    - **실제로 서버가 클라이언트를 직접 다른 페이지로 보내는 것이 아닌 <mark>클라이언트가 GET 요청을 한 번 더 보내도록 응답하는 것</mark>**

#### redirect()
- 클라이언트가 인자에 작성된 주소로 다시 요청을 보내도록 하는 함수

### redirect() 함수 적용
- create view 함수 변경

![0925_ORM_with_view_2025-09-25-11-10-30](images/0925_ORM_with_view_2025-09-25-11-10-30.png)

### redirect 동작 원리
1. redirect 응답을 받은 클라이언트는 **detail url로 다시 요청을 보내게 됨**
2. 결과적으로 detail view 함수가 호출되어 detail view 함수의 반환 결과인 detail 페이지를 응답받게 되는 것

> 결국 사용자는 게시글 작성 후 작성된 게시글의 detail 페이지로 이동하는 것처럼 느끼게 됨

![0925_ORM_with_view_2025-09-25-11-11-49](images/0925_ORM_with_view_2025-09-25-11-11-49.png)

![0925_ORM_with_view_2025-09-25-11-14-08](images/0925_ORM_with_view_2025-09-25-11-14-08.png)

### 게시글 작성 결과
- 게시글 작성 후 생성된 게시글의 detail 페이지로 redirect 되었는지 확인
- create 요청 이후에 detail로 다시 요청을 보냈다는 것을 알 수 있음

![0925_ORM_with_view_2025-09-25-11-14-55](images/0925_ORM_with_view_2025-09-25-11-14-55.png)

# Delete

### delete - 기능 구현
- 최종 결과화면 미리보기

![0925_ORM_with_view_2025-09-25-11-17-31](images/0925_ORM_with_view_2025-09-25-11-17-31.png)

![0925_ORM_with_view_2025-09-25-11-18-18](images/0925_ORM_with_view_2025-09-25-11-18-18.png)

# Update

### Update 로직을 구현하기 위해 필요한 view 함수의 개수는?

![0925_ORM_with_view_2025-09-25-11-40-47](images/0925_ORM_with_view_2025-09-25-11-40-47.png)

- Update 로직 구현에는 **두 개의 view 함수**가 필요

### edit - 페이지 렌더링 기능 구현
- 최종 결과화면 미리보기

![0925_ORM_with_view_2025-09-25-11-41-33](images/0925_ORM_with_view_2025-09-25-11-41-33.png)

- 기능 구현

![0925_ORM_with_view_2025-09-25-11-41-53](images/0925_ORM_with_view_2025-09-25-11-41-53.png)

- 수정 시 이전 데이터가 출력될 수 있도록 작성

    ![0925_ORM_with_view_2025-09-25-11-48-47](images/0925_ORM_with_view_2025-09-25-11-48-47.png)

    - input 요소: 한 줄 텍스트(예: 제목) 
        - value 속성으로 기존 데이터 입력

            ```html
            <input type="text" name="title" id="title" value="기존데이터">
            ```

    - textarea 요소: 여러 줄 텍스트(예: 본문)
        - **value 속성이 없고** 태그 여닫는 사이에 값을 넣음

            ```html
            <textarea name="content" id="content">기존 데이터</textarea>
            ```

    - input과 textarea 모두 기존 데이터를 화면에 미리 출력해 사용자가 편리하게 수정 가능하도록 한다.

- edit 페이지로 이동하기 위한 하이퍼링크 작성

![0925_ORM_with_view_2025-09-25-11-52-51](images/0925_ORM_with_view_2025-09-25-11-52-51.png)

### update - 기능 구현

![0925_ORM_with_view_2025-09-25-11-59-09](images/0925_ORM_with_view_2025-09-25-11-59-09.png)

- 작성 후 게시글 수정 테스트

![0925_ORM_with_view_2025-09-25-11-59-33](images/0925_ORM_with_view_2025-09-25-11-59-33.png)

# 참고

## GET & POST 비교

![0925_ORM_with_view_2025-09-25-12-19-35](images/0925_ORM_with_view_2025-09-25-12-19-35.png)

### GET 요청이 필요한 경우
- 캐싱 및 성능
    - GET 요청은 캐시(Cache)될 수 있고, 이전에 요청한 정보를 새로 요청하지 않고 사용할 수 있음
    - 특히, 동일한 검색 결과를 여러 번 요청하는 경우 GET 요청은 캐시를 활용하여 더 빠르게 응답할 수 있음
- 가시성 및 공유
    - GET 요청은 URL에 데이터가 노출되어 사용자가 해당 URL을 북마크하거나 다른 사람과 공유하기 용이
- RESTful API 설계
    - HTTP 메서드의 의미에 따라 동작하도록 디자인된 API의 일관성을 유지할 수 있음

### HTTP request methods를 활용한 효율적인 URL 구성
- 동일한 URL 한 개로 method에 따라 서버에 요구하는 행동을 다르게 요구
- HTTP Methods를 통해 웹 서버와 클라이언트 간의 통신에서 **'내가 무엇을 할지'** 를 명시적으로 전달
- URL이 같아도 사용되는 메서드(GET, POST 등)에 따라 서버의 동작이 달라짐

![0925_ORM_with_view_2025-09-25-12-22-29](images/0925_ORM_with_view_2025-09-25-12-22-29.png)

### HTTP request methods 실제 활용 예시
- TMDB API 가이드 문서 예시

![0925_ORM_with_view_2025-09-25-12-23-17](images/0925_ORM_with_view_2025-09-25-12-23-17.png)

## 캐시 (Cache)

### 캐시(Cache) 기본 개념
- **데이터나 정보를 임시로 저장**하여, 다시 요청할 때 빠르게 제공하는 저장 공간
- 캐시의 장점
    - 빠른 응답 시간: 이미 저장된 데이터를 즉시 제공하여 사용자 경험 향상
    - 서버 부하 감소: 반복적인 데이터 요청을 줄여 서버 자원 절약

### 실습
- Create
    - 1843. 게시글 생성 및 조회 페이지 생성
    - 1838. 맛집 관리 서비스 만들기 - CR
- Update
    - 1839. 맛집 관리 서비스 만들기 - UR
    - 3033. todo 수정과 코드 개선(with View)
- Delete
    - 1842. 주차 정보 관리 시스템 만들기 - UD
    - 3032. todo 생성과 삭제(with View)
- HTTP response status code
    - 1840. 맛집 관리 서비스 만들기 - 코드 개선
