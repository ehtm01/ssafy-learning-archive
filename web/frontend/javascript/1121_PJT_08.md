# DOM 조작과 Event

### DOM 이란?
- 웹 페이지의 모든 내용을 JavaScript가 이해하고 조작할 수 있도록 만든 구조화된 모델

### DOM 조작이란?
- JS가 웹페이지의 뼈대(HTML)와 디자인(CSS)을 실시간으로 통제하는 핵심 기술

### Event 란?
- 웹 페이지 내에서 발생하는 모든 사건을 말하며, JavaScript가 이를 감지하여 우리가 원하는 특정 동작을 실행하도록 만드는 방아쇠 역할
- DOM 조작과 Event 처리는 웹 페이지를 단순한 정적인 문서가 아니라, 사용자와 끊임없이 대화하고 반응하는 살아있는 인터페이스로 만들어 줌

### DOM 조작과 Event 처리 활용
1. 즉각적인 피드백
    - 사용자와 상호 작용
    - 실시간 유효성 확인
2. 효율적인 정보 관리
    - 평소에는 숨겨뒀다가 필요할 때 보여줌
3. 시각적 매력과 몰입감
    - 사용자 서비스 이용 경험 개선

# Input Event

### Input Event
- 데이터를 입력할 때마다 발생하는 이벤트

### 유사한 입력 이벤트 Keyup
- Input Event
  - 요소의 value(값)이 변경될 때
  - **붙여넣기에도 반응하는** 유효성 검사 기능
- Keyup Event
  - 키보드 키가 눌렸다가 떼어질 때
  - 특정 키(예: Enter 키)를 눌렀을 때만 동작 수행

## 입력 유효성 확인 실습

### 최대 글자 개수를 넘어서면 사용자에게 알려주기
- Input Event를 활용한 유효성 확인

![1121_PJT_08_2025-11-21-08-55-42](images/1121_PJT_08_2025-11-21-08-55-42.png)

### 기본적인 스타일 정의 및 움직임 요소 추가
- Input Event를 활용한 유효성 확인

![1121_PJT_08_2025-11-21-08-56-32](images/1121_PJT_08_2025-11-21-08-56-32.png)

### CSS animation
- JS를 사용하지 않고도 복잡한 움직임을 구현할 수 있게 해주는 CSS의 기능
- **시작**부터 **끝**까지 애니메이션의 **전반적인 규칙**을 정의
- 주요 animation 속성들
  - animation-name: 어떤 동작을 할지 (Keyframes 이름 지정)
  - animation-duration: 몇 초 동안 진행할지
  - animation-timing-functionL: 속도 변화 (느리게, 시작/끝 등)

### CSS keyframes 작성 예시
- CSS 애니메이션의 **개별 동작 단계**와 **변화 지점**을 정의하는 규칙
- @keyframes라는 특별한 문법으로 정의

  ![1121_PJT_08_2025-11-21-09-01-57](images/1121_PJT_08_2025-11-21-09-01-57.png)

### CSS transforms
- 요소를 **이동, 회전, 크기 조절, 기울이기** 등을 할 수 있게 해주는 CSS 속성
  - **transform: [함수]([값]);** 형태로 사용
- transforms에서 사용하는 주요 함수들
  - translate(x, y): x축과 y축으로 이동
  - rotate(각도): 회전
  - scale(x, y): x축과 y축 배율 조절
  - skew(x각도, y각도): x축과 y축 기준으로 기울이기

### Input Event를 활용한 유효성 확인
- JS를 통한 input Event 발생 시 DOM 조작 요소 정의

  ![1121_PJT_08_2025-11-21-09-06-27](images/1121_PJT_08_2025-11-21-09-06-27.png)

### 실행 결과
- 20자를 넘어가면 붉은 색으로 변하며 입력창이 좌우로 흔들리는 것을 확인할 수 있다.

  ![1121_PJT_08_2025-11-21-09-07-06](images/1121_PJT_08_2025-11-21-09-07-06.png)

# Drag Event

### Drag Event
- 웹 페이지의 요소를 **끌어서 이동시키는 과정**에서 발생하는 이벤트
- 단순한 하나의 이벤트가 아닌 끌기 시작부터 끌기 종료까지 모든 단계에서 순서대로 발생하는 여러 개의 이벤트 그룹

### Drag Event 중요한 조건
- draggable = 'true'
  - 드래그 하려는 HTML 요소에서 이 속성을 추가해야 요소가 드래그될 수 있음
  - 기본 값은 false로 요소가 드래그 되지 않음을 확인할 수 있음

### Drag Event 종류
- **요소에서 발생**하는 Event (마우스로 드래그 중인 요소에서 발생)
  - dragstart 이벤트
    - 사용자가 요소를 끌기 시작하는 순간 **끌리는 요소**에서 발생
  - drag 이벤트
    - 사용자가 요소를 끌고 다니는 과정 동안 **끌리는 요소**에서 계속 발생
  - dragend 이벤트
    - 사용자가 마우스 버튼을 놓거나 드래그가 끝나는 순간 **끌리는 요소**에서 발생
- 드래그 **영역에서 발생**하는 Event (드래그 되는 요소 아래 위치한 영역에서 발생)
  - dragenter 이벤트
    - 끌고 있는 요소가 대상 영역 위로 들어올 때 **해당 영역**에서 발생
  - dragover 이벤트
    - 끌고 있는 요소가 대상 영역 위에 머물고 있는 동안 **해당 영역**에서 발생
    - 이 때, 기본 동작을 취소해야 drop이 가능 (마우스 포인터 모양이 다름)
  - dragleave 이벤트
    - 끌고 있는 요소가 대상 영역 밖으로 벗어날 때 **해당 영역**에서 발생
  - drop 이벤트
    - 끌고 있던 요소를 대상 영역 위에 놓는 순간 **해당 영역**에서 발생

### Drag Event 발생 예시
- 사용자가 **아이콘(요소)을 클릭하고 끌기 시작**
  - **아이콘**에서 dragstart 이벤트 발생
- 사용자가 **아이콘을 휴지통(영역) 위로** 가져감
  - **휴지통**에서 dragenter 이벤트 발생
- 사용자가 **아이콘을 휴지통 위에서 움직임**
  - **휴지통**에서 dragover 이벤트가 지속적으로 발생
- 사용자가 **휴지통 위에서 마우스 버튼을 놓음**
  - **휴지통**에서 drop 이벤트 발생 (실제 데이터 처리)
  - **아이콘**에서 dragend 이벤트 발생 (드래그 행위 종료)

## 카드 순서 바꾸기 실습

### 드래그를 통한 카드 순서 바꾸기 실습 진행
- Drag Event 실습
  - 드래그를 통해 카드 위치 변경
  - 드래그 되는 동안 들어갈 곳을 임시로 표시

### Drag Event 실습
- Drag Event 시작과 끝에 대한 이벤트 추가
- 카드가 드래그 되고 있음을 스타일링하기 위함

![1121_PJT_08_2025-11-21-09-22-14](images/1121_PJT_08_2025-11-21-09-22-14.png)

- 카드 배치 원리
  - 현재 드래그 중인 마우스 포인터의 위치와 바닥의 카드 중심 위치를 계산
  - 드래그 중인 마우스 포인터가 **가운데보다 앞쪽**이면 드래그 카드는 **바닥 카드 앞에 위치**
  - 드래그 중인 마우스 포인터가 **가운데보다 뒷쪽**이면 드래그 카드는 **바닥 카드 뒤에 위치**
  
    ![1121_PJT_08_2025-11-21-09-23-21](images/1121_PJT_08_2025-11-21-09-23-21.png)

- 주요 코드

![1121_PJT_08_2025-11-21-09-23-31](images/1121_PJT_08_2025-11-21-09-23-31.png)

- Drag 이벤트에서 preventDefault()를 사용해야 하는 이유
  - 기본적으로 드래그 기본 동작이 드래그를 허용하지 않음이기 때문에 마우스 커서가 드래그 금지 표시로 나타나게 됨

![1121_PJT_08_2025-11-21-09-25-16](images/1121_PJT_08_2025-11-21-09-25-16.png)

- [clientX](https://developer.mozilla.org/ko/docs/Web/API/MouseEvent/clientX)
  - 현재 마우스 위치 값이 담겨 있음
  - Viewport 내의 수평 좌표

![1121_PJT_08_2025-11-21-09-26-33](images/1121_PJT_08_2025-11-21-09-26-33.png)

- [getBoundingClientRect](https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect)
  - 요소의 크기와 Viewport에서의 상대적인 위치 정보를 반환

![1121_PJT_08_2025-11-21-09-27-55](images/1121_PJT_08_2025-11-21-09-27-55.png)

- 가장 가까운 카드를 찾는 알고리즘

![1121_PJT_08_2025-11-21-09-28-11](images/1121_PJT_08_2025-11-21-09-28-11.png)

- [insertBefore](https://developer.mozilla.org/ko/docs/Web/API/Node/insertBefore)
  - 기준이 되는 노드의 앞에 새로운 노드를 추가할 때 사용

### 실행 결과
- 카드를 드래그 하면 추가될 위치가 나타나며 이동시킬 수 있음을 확인

  ![1121_PJT_08_2025-11-21-09-29-20](images/1121_PJT_08_2025-11-21-09-29-20.png)

# Scroll Event

### Scroll Event
- 웹 페이지의 콘텐츠를 상하좌우로 이동(스크롤)시킬 때마다 지속적으로 발생하는 이벤트

### Scroll Event 주요 속성
- window.scrollY
  - 브라우저 창의 **수직 스크롤 위치**
  - **권장하는 표준 속성**
- **element.scrollHeight**
  - 요소에 **포함된 전체 콘텐츠의 높이로 스크롤 되지 않은 부분까지 포함되며** 총 길이를 파악하여 스크롤 막대의 끝에 도달했는지 확인할 때 사용

### 스크롤 시 나타나는 요소 실습
- 투명하게 설정된 요소의 상단 위치를 스크롤 이벤트가 발생할 때마다 확인
- 해당 요소의 상단 위치가 특정 위치에 도달하게 되면 투명도를 JS로 조절하여 나타나게 만듦
- transition 속성을 활용, 부드럽게 나타나도록 설정

### 스크롤 나타나는 요소 실습
- 주요 코드

  ![1121_PJT_08_2025-11-21-09-36-43](images/1121_PJT_08_2025-11-21-09-36-43.png)

## 스크롤 진행률 표시 실습

### 스크롤 진행도 표시 실습
- 화면 상단에 스크롤에 따른 진행률을 나타내는 서비스들이 존재
- 내용이 많아 스크롤이 길 때 사용 가능
  - 주로 언론사 기사 페이지에서 활용

    ![1121_PJT_08_2025-11-21-09-37-29](images/1121_PJT_08_2025-11-21-09-37-29.png)

- 주요 원리
  - 진행률에 따라 프로그래스 바의 너비를 DOM 조작을 통해 갱신
  - 스크롤 진행률 계산 방법
    - 현재 스크롤 높이 / 전체 높이 (X)
    - 처음에 보여지는 높이는 제외해야 스크롤 가능 범위가 됨
      - 스크롤 한다는 것은 보이지 않는 부분을 내려간다는 의미
      - **스크롤 이동 가능 범위 = 전체 높이 - Viewport 높이**
    - **스크롤 진행률 = 현재 스크롤 위치 / 스크롤 이동 가능 범위**

![1121_PJT_08_2025-11-21-09-40-35](images/1121_PJT_08_2025-11-21-09-40-35.png)

- 주요 코드

  ![1121_PJT_08_2025-11-21-09-40-46](images/1121_PJT_08_2025-11-21-09-40-46.png)

  - [documentElement.scrollHeight](https://developer.mozilla.org/ko/docs/Web/API/Element/scrollHeight)
    - 콘텐츠의 **총 높이**를 나타내며, 바깥으로 넘쳐서 보이지 않는 콘텐츠도 포함함
  - [window.innerHeight](https://developer.mozilla.org/ko/docs/Web/API/Window/innerHeight)
    - 막대 높이를 포함한 **창 내부 높이**

# Parallax Scroll

### Parallax Scroll
- 스크롤할 때 **화면의 배경과 앞에 보이는 내용이 서로 다른 속도로 움직여**, 화면에 깊이나 3D 같은 입체감을 주는 시각적 효과

  ![1121_PJT_08_2025-11-21-09-43-40](images/1121_PJT_08_2025-11-21-09-43-40.png)

### Parallax Scroll 적용 예시

![1121_PJT_08_2025-11-21-09-45-36](images/1121_PJT_08_2025-11-21-09-45-36.png)

![1121_PJT_08_2025-11-21-09-45-56](images/1121_PJT_08_2025-11-21-09-45-56.png)

## Parallax Scroll 실습 1

### Parallax Scroll 원리 실습 1
- 주요 코드
  - 요소 별로 움직이는 속도를 설정

    ![1121_PJT_08_2025-11-21-09-46-24](images/1121_PJT_08_2025-11-21-09-46-24.png)

    ![1121_PJT_08_2025-11-21-09-46-31](images/1121_PJT_08_2025-11-21-09-46-31.png)

    - 스크롤을 내리면 위로 올라갈 수 있도록 음수로 지정
    - 스크롤 위치와 속도를 곱하여 이동하는 거리를 요소별로 다르게 지정

- 스크롤 전 / 후

  ![1121_PJT_08_2025-11-21-09-47-31](images/1121_PJT_08_2025-11-21-09-47-31.png)

## Parallax Scroll 실습 2

### Parallax Scroll 원리 실습 2
- 앞서 적용한 기본 Parallax Scroll 원리를 활용하여 스크롤 시 요소별 동작을 부여하여 스크롤 했을 때 애니메이션처럼 동작하도록 설정

![1121_PJT_08_2025-11-21-09-48-20](images/1121_PJT_08_2025-11-21-09-48-20.png)

- 주요 코드

  ![1121_PJT_08_2025-11-21-09-49-21](images/1121_PJT_08_2025-11-21-09-49-21.png)

# 참고

### Scroll Event 활용하기
- 앞서 실습한 내용을 바탕으로 보다 드라마틱한 페이지 연출이 가능함
  - 스크롤에 따른 배경색 변경하는 실습
  - 같은 방향의 스크롤임에도 가로, 세로 복합적으로 동작

## 스크롤을 활용한 배경색 변경 실습

### 스크롤을 활용한 배경색 변경 실습
- 동작 원리
  - 스크롤 진행률은 0~1 의 범위를 가지고 있음
    - 스크롤 진행률 = 현재 스크롤 위치 / 스크롤 가능한 높이
  - 이를 인덱스의 개수만큼 곱하고, 내림 계산을 하면 구간 별로 index 를 다르게 가져갈 수 있음
    - 배열의 길이가 5 라면, 진행도 배열의 길이만큼 곱하고 내림을 하면 구간 별로 index 가 계산됨
- 예시
  - 스크롤 진행률이 0.3 부근인 경우, 5를 곱하면 1.5가 되고 내림 계산을 하면 1이 됨. 이 때 **index는 1**로 설정할 수 있음
  - 스크롤 진행률이 0.5 부근인 경우, 5를 곱하면 2.5가 되고 내림 계산을 하면 2이 됨. 이 때 **index는 2**로 설정할 수 있음
  - 스크롤 진행률이 0.8 부근인 경우, 5를 곱하면 4가 됨. 이 때 **index는 4**로 설정할 수 있음

- 실습 내용 
  - 스크롤에 따라 새벽, 아침, 낮, 저녁, 밤 총 5구간을 설정하여 배경색을 달리 하고, 스크롤 진행도에 따라 해와 달의 움직임을 표현하는 실습

- 주요 코드 (배경 인덱스)

  ![1121_PJT_08_2025-11-21-09-53-15](images/1121_PJT_08_2025-11-21-09-53-15.png)

  - 진행률 계산에서 min을 사용한 이유
    - 모바일이나 특정 브라우저에서 높이보다 스크롤의 위치가 넘어가는 경우가 발생하여 진행률이 1 이상이 될 수 있음
    - 0 ~ 1 사이의 값이 아닌 1 이상의 값이 나오는 경우가 발생하면 최대 index 를 넘어버리게 되어 min 을 통해 제한

- 해의 이동 코드

  ![1121_PJT_08_2025-11-21-09-55-36](images/1121_PJT_08_2025-11-21-09-55-36.png)

- 달의 이동 코드

  ![1121_PJT_08_2025-11-21-09-55-48](images/1121_PJT_08_2025-11-21-09-55-48.png)

### 심화 기능
- 배경색을 부드럽게 변경하기 위한 선형 보간 게산 추가
  - 선형 보간: 두 값 사이를 부드럽게 이어주는 계산 방법
    - 예: 빨강(255, 0, 0)과 파랑(0, 0, 255) 사이의 중간 색상 구하기
  - 시작값 + (끝값 - 시작값) * 진행률
- 해와 달을 곡선 형태로 표기하기 위한 포물선 곡선 계산 공식 추가
  - 기본 포물선 공식: ax^2 + bx + c
  - 수학적 원리
    - 2 * normalizedX * (1 - normalizedX) 포물선 공식
    - normalizedX는 0~1 사이의 값 (진행률)

### 실제 응용 서비스
- 연속된 이미지를 불러와서 스크롤 진행도에 따라 index를 변경하면 자연스럽게 동영상이 재생되는 효과를 낼 수 있음

![1121_PJT_08_2025-11-21-09-57-57](images/1121_PJT_08_2025-11-21-09-57-57.png)

## 가로, 세로 스크롤 혼합 실습

### 가로, 세로 스크롤 혼합 실습
- 동작 원리
  - 붉은 색 점선이 사용자에게 보여지는 화면일 때, 스크롤 내려감과 함께 가로 배치된 요소가 이동하면서 보여짐

  ![1121_PJT_08_2025-11-21-09-58-32](images/1121_PJT_08_2025-11-21-09-58-32.png)

- 실습을 위해 필요한 CSS 속성
  - 가로 스크롤하는 영역(horizontal-track)의 너비(width)와 실제 스크롤(horizontal-container)되는 높이(height)가 같아야 함
    - horizontal-track의 너비는 개별 page의 개수로 동일하게 맞춤
  - 가로 정렬을 위해 Flex 설정이 필요함
  - 가로 정렬된 요소를 숨기기 위해 **overflow: hidden** 설정이 필요함
    - hidden을 하는 이유, 가로 스크롤바를 없애기 위함
  - 가로 스크롤 하는 동안 viewport에 고정하기 위해 sticky 설정이 필요함
    - 하지 않으면 스크롤과 함께 올라가버림
    - fixed인 경우 가로 이동 후에도 고정되어 있게 됨

- 동작 원리
  - 스크롤을 하다가 horizontal-container 영역에서 가로 스크롤이 동작할 영역
  - 스크롤을 하게 되면 horizontal-container의 top 위치가 이동함
  - horizontal-container의 top 위치가 스크롤되어 이동하는 거리만큼 horizontal-track의 위치도 이동하여 화면에 출력하는 원리

    ![1121_PJT_08_2025-11-21-10-08-14](images/1121_PJT_08_2025-11-21-10-08-14.png)

- 주요 코드

  ![1121_PJT_08_2025-11-21-10-08-30](images/1121_PJT_08_2025-11-21-10-08-30.png)

### 실제 적용 사례
- PC 화면일 때 확인 가능

![1121_PJT_08_2025-11-21-10-08-52](images/1121_PJT_08_2025-11-21-10-08-52.png)