# 데이터 타입

### 원시 자료형(Primitive type)
- 값(value) 자체가 변수에 직접 저장되는 자료형
- 불변(immutable)이며, 변수 간 할당 시 값이 복사
  - 값이 불변이라는 것은 값의 일부를 직접 수정할 수 없다는 의미
  - let str = 'ssafy'; str[0] = 'S'; 처럼 할당하는 것은 불가능
- Number, String, Boolean, null, undefined

### 참조 자료형(Reference type)
- 데이터가 저장된 메모리의 주소가 변수에 저장되는 자료형
- 가변(Mutable)이며, 변수 간 할당 시 주소가 복사
  - 주소를 복사하므로, 복사본을 수정하면 원본의 값도 함께 변경됨
- Objects(Object, Array, Function)

### 원시 자료형 예시
- 변수에 할당될 때 값이 복사됨
> 변수 간에 서로 영향을 미치지 않음

![1118_JS_BasicSyntax_2025-11-18-08-45-44](images/1118_JS_BasicSyntax_2025-11-18-08-45-44.png)

### 참조 자료형 예시
- 객체를 생성하면 객체의 메모리 주소를 변수에 할당
> 변수 간에 서로 영향을 미침

![1118_JS_BasicSyntax_2025-11-18-08-46-08](images/1118_JS_BasicSyntax_2025-11-18-08-46-08.png)

## 원시 자료형

### 원시 자료형 종류
- Number
- String
- null
- undefined
- Boolean

### 원시 자료형 - Number
- Number: 정수 또는 실수형 숫자를 표현하는 자료형
  - 사칙연산 및 나머지 연산 가능
  - 문자열과 + 연산 시, 숫자가 문자열로 자동 형 변환되어 연결
  - 정수와 실수 구분이 없고, 모든 숫자를 단일 타입으로 처리

![1118_JS_BasicSyntax_2025-11-18-08-49-37](images/1118_JS_BasicSyntax_2025-11-18-08-49-37.png)

### 원시 자료형 - String
- String: 텍스트 데이터를 표현하는 자료형
  - '+' 연산자를 사용해 문자열끼리 결합
  - 뺄셈, 곱셈, 나눗셈 불가능

![1118_JS_BasicSyntax_2025-11-18-08-51-03](images/1118_JS_BasicSyntax_2025-11-18-08-51-03.png)

### Template literals
- 내장된 표현식을 허용하는 향상된 문자열 작성 방식
- Backtick(**``**)을 이용하며, 여러 줄에 걸쳐 문자열을 정의할 수도 있고 JavaScript의 변수를 문자열 안에 바로 연결할 수 있음
- 표현식은 **"$"** 와 중괄호 (**{expression}**) 로 표기
- ES6+ 부터 지원

![1118_JS_BasicSyntax_2025-11-18-08-52-53](images/1118_JS_BasicSyntax_2025-11-18-08-52-53.png)

### null
- 프로그래머가 의도적으로 **'값이 없음'** 을 나타낼 때 사용

![1118_JS_BasicSyntax_2025-11-18-08-53-35](images/1118_JS_BasicSyntax_2025-11-18-08-53-35.png)

### undefined
- 시스템이나 JavaScript 엔진이 **'값이 할당되지 않음'** 을 나타낼 때 사용

![1118_JS_BasicSyntax_2025-11-18-08-54-05](images/1118_JS_BasicSyntax_2025-11-18-08-54-05.png)

#### TIP
- 'null'의 타입은 'object', 'undefined'의 타입은 'undefined' 이므로 타입 검사 시 주의
- return 이 없는 함수나, 인자가 전달되지 않은 매개변수는 기본적으로 undefined가 할당됨
- 산술 연산 시 'null'은 0으로 취급되지만, 'undefined'는 계산 불가능한 NaN 값을 만듦

### 원시 자료형 - Boolean
- Boolean: 참과 거짓을 나타내는 논리적인 자료형
  - 조건문 또는 반복문에서 Boolean이 아닌 데이터 타입은 "자동 형변환 규칙"에 따라 true 또는 false로 변환됨

### 자동 형변환

![1118_JS_BasicSyntax_2025-11-18-08-59-10](images/1118_JS_BasicSyntax_2025-11-18-08-59-10.png)

# 연산자

### 연산자 종류
- 할당 연산자
- 증가 & 감소 연산자
- 비교 연산자
- 동등 연산자
- 일치 연산자
- 논리 연산자

### 할당 연산자
- 오른쪽에 있는 피연산자의 평가 결과를 왼쪽 피연산자에 할당하는 연산자
- 단축 연산자 지원
  - 단축 연산자: x = x + 1 을 x += 1 처럼 짧게 줄여주는 연산자

![1118_JS_BasicSyntax_2025-11-18-09-00-41](images/1118_JS_BasicSyntax_2025-11-18-09-00-41.png)

### 증가 & 감소 연산자
- 증가 연산자 ('++')
  - 피연산자를 증가(1을 더함)시키고 연산자의 위치에 따라 증가하기 전이나 후의 값을 반환
- 감소 연산자 ('--')
  - 피연산자를 감소(1을 뺌)시키고 연산자의 위치에 따라 감소하기 전이나 후의 값을 반환
> 코드의 가독성을 위해 a += 1, a -= 1과 같이 더 명시적인 표현을 권장

![1118_JS_BasicSyntax_2025-11-18-09-02-26](images/1118_JS_BasicSyntax_2025-11-18-09-02-26.png)

### 비교 연산자
- 피연산자들(숫자, 문자, Boolean 등)을 비교하고 결과 값을 boolean으로 반환하는 연산자

![1118_JS_BasicSyntax_2025-11-18-09-02-55](images/1118_JS_BasicSyntax_2025-11-18-09-02-55.png)

### 동등 연산자 (==)
- 두 피연산자가 같은 값으로 평가되는지 비교한 후 boolean 값을 반환
- '암묵적 타입 변환' 통해 타입을 일치시킨 후 같은 값인지 비교
  - 0 == false, '' == [] 가 true 가 되는 등, 직관과 다른 암묵적 타입 변환이 일어나니 주의
- 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별
  - 내용이 같아도 다른 객체이면 false. [1] == [1] 은 false 이니 주의

![1118_JS_BasicSyntax_2025-11-18-09-03-41](images/1118_JS_BasicSyntax_2025-11-18-09-03-41.png)

### 일치 연산자 (===)
- 두 피연산자의 값과 타입이 모두 같은 경우 **true**를 반환
- 같은 객체를 가리키거나, 같은 타입이면서 같은 값인지를 비교
- 엄격한 비교가 이뤄지며 암묵적 타입 변환이 발생하지 않음
- 특별한 경우를 제외하고는, 예측하지 못한 결과를 방지하기 위해 **일치 연산자(===) 사용을 권장**

![1118_JS_BasicSyntax_2025-11-18-09-07-40](images/1118_JS_BasicSyntax_2025-11-18-09-07-40.png)

### 논리 연산자
- and 연산
  - &&
- or 연산
  - ||
- not 연산
  - !
- 단축 평가 지원

![1118_JS_BasicSyntax_2025-11-18-09-08-14](images/1118_JS_BasicSyntax_2025-11-18-09-08-14.png)

# 조건문

### if
- if: 조건 표현식의 결과값을 boolean 타입으로 변환 후 참/거짓을 판단

![1118_JS_BasicSyntax_2025-11-18-09-09-05](images/1118_JS_BasicSyntax_2025-11-18-09-09-05.png)

### 삼항 연산자
- 간단한 조건부 로직을 간결하게 표현할 때 유용
- 복잡한 로직이나 대다수의 경우에는 가독성이 떨어질 수 있으므로 적절한 상황에서만 사용할 것
- condition
  - 평가할 조건 (true 또는 false로 평가)
- expression1
  - 조건이 true일 경우 반환할 값 또는 표현식
- expression2
  - 조건이 false일 경우 반환할 값 또는 표현식

![1118_JS_BasicSyntax_2025-11-18-09-10-34](images/1118_JS_BasicSyntax_2025-11-18-09-10-34.png)

- 삼항 연산자 표현식: condition ? expression1 : expression2

# 반복문

### 반복문 종류
- while
- for
- for ... in
- for ... of

### while 반복문
- while: 조건문이 참이면 문장을 계속해서 수행

![1118_JS_BasicSyntax_2025-11-18-09-11-59](images/1118_JS_BasicSyntax_2025-11-18-09-11-59.png)

### for 반복문
- for: 특정한 조건이 거짓으로 판별될 때까지 반복

![1118_JS_BasicSyntax_2025-11-18-09-12-21](images/1118_JS_BasicSyntax_2025-11-18-09-12-21.png)

### for 동작 원리

![1118_JS_BasicSyntax_2025-11-18-09-12-45](images/1118_JS_BasicSyntax_2025-11-18-09-12-45.png)

## for ... in

### for ... in 반복문
- for ... in: 객체의 열거 가능한(enumerable) 속성(property)의 **키(key)**에 대해 반복

![1118_JS_BasicSyntax_2025-11-18-09-17-56](images/1118_JS_BasicSyntax_2025-11-18-09-17-56.png)

## for ... of

### for ... in 반복문
- for ... of: 반복 가능한(iterable) 객체(배열, 문자열 등)의 **값(value)**에 대해 반복

![1118_JS_BasicSyntax_2025-11-18-09-19-20](images/1118_JS_BasicSyntax_2025-11-18-09-19-20.png)

## for ... in 과 for ... of

### for ... in
- 배열과 객체

![1118_JS_BasicSyntax_2025-11-18-09-21-09](images/1118_JS_BasicSyntax_2025-11-18-09-21-09.png)

### for ... of
- 배열과 객체

![1118_JS_BasicSyntax_2025-11-18-09-21-31](images/1118_JS_BasicSyntax_2025-11-18-09-21-31.png)

### 배열 반복과 for ... in
- 객체의 관점에서 보면 배열의 인덱스도 "정수 형태의 이름을 가진 열거 가능한 속성"
- for ... in 은 정수가 아닌 이름과 속성을 포함하여 열거 가능한 모든 속성을 반환
- 내부적으로 for ... in 은 배열의 반복자가 아닌 속성 열거를 사용하기 때문에 특정 순서에 따라 인덱스를 반환하는 것을 보장할 수 없음
> 따라서 for ... in 은 인덱스의 순서가 중요한 배열에서는 사용하지 않음

> 배열에서는 **for 문, for ... of 를 사용**
- 객체 관점에서 배열의 인덱스는 정수 이름을 가진 속성이기 때문에 인덱스가 출력됨 (순서 보장 X)

![1118_JS_BasicSyntax_2025-11-18-09-26-39](images/1118_JS_BasicSyntax_2025-11-18-09-26-39.png)

- for ... in 은 배열의 값이 아닌 인덱스를, 그것도 숫자가 아닌 '문자열'로 반환하니 주의
- 배열의 프로토타입에 추가된 속성까지 순회할 수 있어, 예기치 않은 버그를 유발할 수 있음

### 반복문 사용 시 const 사용 여부
- for 문
  - for (let i = 0; i < arr.length; i++) {...}의 경우에는 최초 정의한 i 를 "재할당" 하면서 사용하기 때문에 **const를 사용하면 에러 발생**
- for ... in, for ... of
  - 재할당이 아니라, 매 반복마다 다른 속성 이름이 변수에 지정되는 것이므로 **const를 사용해도 에러가 발생하지 않음**
  - 단, const 특징에 따라 블록 내부에서 변수를 수정할 수 없음

### 반복문 종합

![1118_JS_BasicSyntax_2025-11-18-09-29-31](images/1118_JS_BasicSyntax_2025-11-18-09-29-31.png)

# 함수

### Function
- 참조 자료형에 속하며 모든 함수는 Function object

## 함수 정의

### 함수 구조

![1118_JS_BasicSyntax_2025-11-18-09-32-33](images/1118_JS_BasicSyntax_2025-11-18-09-32-33.png)

- function 키워드
- 함수의 이름
- 함수의 매개변수
- 함수의 body를 구성하는 statements
> return 문이 없거나 return 뒤에 값이 없으면, 함수는 undefined를 반환

### 함수 정의 2가지 방법
- 선언식(function declaration)

![1118_JS_BasicSyntax_2025-11-18-09-33-45](images/1118_JS_BasicSyntax_2025-11-18-09-33-45.png)

![1118_JS_BasicSyntax_2025-11-18-09-34-18](images/1118_JS_BasicSyntax_2025-11-18-09-34-18.png)

- 표현식(function expression)

![1118_JS_BasicSyntax_2025-11-18-09-34-05](images/1118_JS_BasicSyntax_2025-11-18-09-34-05.png)

![1118_JS_BasicSyntax_2025-11-18-09-34-25](images/1118_JS_BasicSyntax_2025-11-18-09-34-25.png)

### 함수 선언식 특징
- 호이스팅 됨
  - 호이스팅: 자바스크립트 엔진이 코드 실행 전 변수와 함수 선언을 스코프 최상단으로 끌어올리는 동작 방식
  - 선언식으로 된 함수는 선언 전에 호출하는 것이 가능해짐
- 코드의 구조와 가독성 면에서는 표현식에 비해 장점이 있음

### 함수 표현식 특징
- 호이스팅 되지 않음
  - 변수 선언만 호이스팅되고 함수 할당은 실행 시점에 이뤄짐
- 함수 이름이 없는 '익명 함수'를 사용할 수 있음
  - 익명 함수: 이름 없이, 필요할 때 즉시 만들어서 사용하는 일회용 함수

![1118_JS_BasicSyntax_2025-11-18-09-36-34](images/1118_JS_BasicSyntax_2025-11-18-09-36-34.png)

![1118_JS_BasicSyntax_2025-11-18-09-35-13](images/1118_JS_BasicSyntax_2025-11-18-09-35-13.png)

### 함수 표현식 사용을 권장하는 이유
- 예측 가능성
  - 호이스팅의 영향을 받지 않아 코드 실행 흐름을 더 명확하게 예측할 수 있음
- 유연성
  - 변수에 할당되므로 함수를 값으로 다루기 쉬움
- 스코프 관리
  - 블록 스코프를 가지는 let이나 const와 함께 사용하여 더 엄격한 스코프 관리가 가능

## 매개변수

### 매개변수 정의 방법
- 매개 변수: 함수가 외부로부터 값을 전달받기 위해 만들어 놓은 변수
1. 기본 함수 매개 변수
2. 나머지 매개 변수

### 1. 기본 함수 매개 변수 (Default function parameter)
- 함수 호출 시 인자를 전달하지 않거나 undefined를 전달할 경우, 지정된 기본값으로 매개변수를 초기화

![1118_JS_BasicSyntax_2025-11-18-09-38-51](images/1118_JS_BasicSyntax_2025-11-18-09-38-51.png)

### 2. 나머지 매개변수 (Rest parameter)
- 정해지지 않은 개수의 인자들을 배열로 모아서 받는 방법
- 작성 규칙
  - 함수 정의 시 나머지 매개변수는 하나만 작성할 수 있음
  - 나머지 매개변수는 함수 정의에서 매개변수 마지막에 위치해야 함

![1118_JS_BasicSyntax_2025-11-18-09-39-44](images/1118_JS_BasicSyntax_2025-11-18-09-39-44.png)

### 매개변수와 인자 개수가 불일치할 때
- 매개변수 개수 > 인자 개수
> 누락된 인자는 undefined로 할당

![1118_JS_BasicSyntax_2025-11-18-09-42-39](images/1118_JS_BasicSyntax_2025-11-18-09-42-39.png)

### 매개변수와 인자 개수가 불일치할 때
- 매개변수 개수 < 인자 개수
> 초과 입력한 인자는 사용하지 않음

![1118_JS_BasicSyntax_2025-11-18-09-43-04](images/1118_JS_BasicSyntax_2025-11-18-09-43-04.png)

## Spread syntax

### Spread syntax '...'
- 전개 구문
- 배열이나 문자열처럼 반복 가능한(iterable) 항목들을 개별 요소로 펼치는 것
- 전개 대상에 따라 역할이 다름
  > 배열이나 객체의 요소를 개별적인 값으로 분리하거나 다른 배열이나 객체의 요소를 현재 배열이나 객체에 추가하는 등

### 전개 구문 활용처
1. 함수와의 사용
    1. 함수 호출 시 인자 확장
    2. 나머지 매개변수 (압축)
2. 객채와의 사용 (객체 파트에서 진행)
3. 배열과의 활용 (배열 파트에서 진행)

### 전개 구문 활용
- 함수와의 사용
  1. 인자 확장 (함수 호출 시)

  ![1118_JS_BasicSyntax_2025-11-18-09-44-58](images/1118_JS_BasicSyntax_2025-11-18-09-44-58.png)

  2. 나머지 매개변수 (압축)

  ![1118_JS_BasicSyntax_2025-11-18-09-46-43](images/1118_JS_BasicSyntax_2025-11-18-09-46-43.png)

## 화살표 함수 표현식

### 화살표 함수 표현식
- 화살표 함수 표헌식(Arrow function expressions): 함수 표현식의 간결한 표현법

![1118_JS_BasicSyntax_2025-11-18-09-54-08](images/1118_JS_BasicSyntax_2025-11-18-09-54-08.png)

### 화살표 함수 작성 과정
1. function 키워드 제거 후 매개변수와 중괄호 사이에 화살표(**=>**) 작성

![1118_JS_BasicSyntax_2025-11-18-09-55-25](images/1118_JS_BasicSyntax_2025-11-18-09-55-25.png)

2. 함수의 매개변수가 하나 뿐이라면, 매개변수의 '**()**' 제거 가능<br>
(단, 생략하지 않는 것을 권장)

![1118_JS_BasicSyntax_2025-11-18-09-56-15](images/1118_JS_BasicSyntax_2025-11-18-09-56-15.png)

3. 함수 본문의 표현식이 한 줄이라면, '**{}**' 와 '**return**' 제거 가능

![1118_JS_BasicSyntax_2025-11-18-09-57-05](images/1118_JS_BasicSyntax_2025-11-18-09-57-05.png)

# 참고

## NaN 예시

### NaN을 반환하는 경우 예시
1. 숫자로서 읽을 수 없음 (Number(undefined))
2. 결과가 허수인 수학 계산식 (Math.sqrt(-1))
3. 피연산자가 NaN (7 ** NaN)
4. 정의할 수 없는 계산식 (0 * Infinity)
5. 문자열을 포함하면서 덧셈이 아닌 계산식 ('가' / 3)
- NaN은 자기 자신과 비교헤도 False가 나오는 유일한 값 (NaN === NaN  // false)
- NaN은 '숫자가 아님'이라는 뜻이지만, 타입을 확인하면 'number'가 반환됨

## null & undefined

### '값이 없음' 에 대한 표현이 null과 undefined 2가지인 이유
1. 역사적 맥락
    - JavaScript가 처음 만들어질 때, null은 '객체가 없음'을 나타내기 위해 도입
    - undefined는 나중에 추가되어 '값이 할당되지 않음'을 나타내게 됨
2. typeof null의 결과가 "object"인 이유 (역사적 배경)
    - 초기 버전에서 값의 타입을 나타내는 데 32비트 시스템을 사용
    - 타입 태그로 하위 3비트를 사용했는데, '000'은 객체를 나타냄
    - null은 모든 비트가 0인 특별한 값(NULL 포인터)으로 표현되었는데, 하필 객체 타입을 나타내는 태그 또한 000이었기 때문에 null을 객체로 잘못 판별하게 됨

![1118_JS_BasicSyntax_2025-11-18-10-01-14](images/1118_JS_BasicSyntax_2025-11-18-10-01-14.png)

3. ECMAScript의 표준화
    - ECMAScript 명세에서는 null을 원시 자료형으로 정의
    - 그러나 typeof null의 결과는 역사적인 이유로 "object"를 유지
    - ECMLScript 5 개발 중 이문제를 수정하려는 시도가 있었지만, 이미 typeof null === 'object'라는 전제하에 만들어진 수 많은 웹사이트와의 하위 호환성 문제 때문에 수정되지 못 함

![1118_JS_BasicSyntax_2025-11-18-10-04-03](images/1118_JS_BasicSyntax_2025-11-18-10-04-03.png)

## 화살표 함수 심화

![1118_JS_BasicSyntax_2025-11-18-10-04-14](images/1118_JS_BasicSyntax_2025-11-18-10-04-14.png)

### 실습
- 연산자
  - 2963. 다양한 연산자
  - 3076. 연산자와 제어문
- 반복문
  - 2964. 배열 순회
  - 3077. 배열과 객체 순회
  - 3078. 반복문과 제어문
  - 2961. 기초 문법 디버깅 - 반복문
- 조건문
  - 2960. 기초 문법 디버깅 - 조건문과 변수 선언
  - 2965. 제어문