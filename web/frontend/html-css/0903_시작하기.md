## 진법 변환

### 10진수 -> 2진수로 변환 구현
- 10진수를 지속적으로 2로 나누어 구현
- 마지막으로 List를 거꾸로 뒤집기

![0903_시작하기_2025-09-03-09-03-21](images/0903_시작하기_2025-09-03-09-03-21.png)

### 2진수를 10진수로 변환
- 수기로 계산할 수 있어야 함

![0903_시작하기_2025-09-03-09-04-13](images/0903_시작하기_2025-09-03-09-04-13.png)

### 16진수와 2진수 변환
- 2진수, 10진수간 변환은 연산이 많으나, 2진수, 16진수간 변환은 연산이 없음
- 진법 변환을 빠르게 할 수 있으려면 진수 표를 암기하는 것을 권장함

![0903_시작하기_2025-09-03-09-28-17](images/0903_시작하기_2025-09-03-09-28-17.png)

### 16진수 0xF9를 2진수로 변환해보기
- 정답: 1111 1001

![0903_시작하기_2025-09-03-09-29-07](images/0903_시작하기_2025-09-03-09-29-07.png)

### 16진수 0xBB3를 2진수로 변환해보기
- 정답: 1011 1011 0011

### 2진수 1100101111를 16진수로 변환해보기
- 먼저 네 자리씩 끊어주기
    - 11 0010 1111
- 정답: 0x32F

### 16진수를 입력받으면, 2진수로 출력해주는 프로그램
- 오른쪽 표에서 2진수 부분을 리스트에 모두 저장해두고 구현

### 0과 1로 이루어진 1차 배열에서 7개씩 수를 묶어, 10진수로 출력하기
- 예시
    ![0903_시작하기_2025-09-03-09-31-28](images/0903_시작하기_2025-09-03-09-31-28.png)
    - 이면 1, 13을 출력한다.

- 입력 예
    - 0000000111100000011000000111100110000110000111100111100111111001100111
- 출력 결과: 0 120 12 7 76 24 60 121 124 103

## 비트 연산

### 비트와 바이트
- 1 bit: 0과 1을 표현하는 정보의 단위
- 1 Byte: 8-bit를 묶어 1 Byte라고 함 (메모리 주소가 부여되는 단위)
- 예시
    - 1001011011011100 은 총 몇 비트이면서, 몇 바이트인가?
    - 정답: 16 bit, 2 Byte

### 비트 연산
- 컴퓨터의 CPU 내부적으로 비트 연산을 사용해 덧셈, 뺄셈, 곱셈 등을 계산함
- 비트 연산 챕터의 목적
    - 사람이 사용하는 사칙연산(+, *, /, -)이 아닌 컴퓨터가 사용하는 연산인 <b>"비트 연산"</b>을 이해해보자.
    - 더 나아가, **프로그래밍에서 비트연산을 활용한 코딩 방법을 익혀보자.**

### AND와 OR 비트연산자 이해하기
- a AND b: a, b 둘 다 1일 때만 결과가 1, 그 외에는 0
- a OR b: a, b 둘 중 하나만 1이면 결과가 1, 그 외에는 0

연산자|연산자의 기능
:-:|:-:
&|비트 단위로 AND 연산을 한다.<br>예) num1 & num2
\||비트 단위로 OR 연산을 한다.<br>예) num1 \| num2

### 파이썬 구현
- 7 & 5 -> 이진수로 표현하면 0b**111** & 0b**101**

![0903_시작하기_2025-09-03-09-40-01](images/0903_시작하기_2025-09-03-09-40-01.png)

### 파이썬에서 2진수, 16진수, 10진수 변환하여 출력하기
- 2진수는 숫자 0과 소문자 b -> 0b를 접두사로 붙여 표현
- 16진수는 숫자 0과 소문자 x -> 0x를 접두사로 붙여 표현

![0903_시작하기_2025-09-03-09-40-45](images/0903_시작하기_2025-09-03-09-40-45.png)

### [도전] 먼저 수기로 연산을 해본다.
- 이후, 직접 파이썬으로 구현하여 테스트
    - 0b11011110 & 0b11011
    - 0x4A3 \| 25_(10)

### XOR 와 NOT 연산자
- ^: XOR 연산자, 둘 다 1이거나 0인 경우는 0이다.

연산자|연산자의 기능
:-:|:-:
^|비트 단위로 XOR 연산을 한다. (같으면 0, 다르면 1)<br>예) num1 ^ num2

![0903_시작하기_2025-09-03-09-45-51](images/0903_시작하기_2025-09-03-09-45-51.png)

### 신기한 XOR
- 어떤 값이던 특정 수로 2회 XOR를 하면 원래 수로 돌아옴
    - 7070 ^ 1004 = 6258
    - 6258 ^ 1004 = 7070

### 암호화에 사용되는 XOR
- 친구 1과 친구 2는 서로 비밀코드를 1004로 약속

![0903_시작하기_2025-09-03-09-47-05](images/0903_시작하기_2025-09-03-09-47-05.png)

### [도전] 암호화 프로그램 제작하기
- 수를 입력 받고, 암호화를 해주거나(인코딩), 암호를 해제해주는(디코딩) 프로그램을 제작
- KEY 값은 1004로 정함
- 예시 1
    - E 1000 # 수 1000을 인코딩하여 출력한다.
- 예시 2
    - D 4 # 수 4를 디코딩하여 출력한다.

### 비트연산자
- Left Shift <<: 특정 수만큼 비트를 왼쪽으로 밀어냄
- Right Shift >>: 특정 수만큼 비트를 오른쪽으로 밀어냄 (우측 비트들이 제거됨)

연산자|연산자의 기능
:-:|:-:
<<|피연산자의 비트 열을 왼쪽으로 이동<br>예) num << 2   # 2회 이동
\>>|피연산자의 비트 열을 오른쪽으로 이동<br>예) num >> 2    # 2회 이동

![0903_시작하기_2025-09-03-10-03-04](images/0903_시작하기_2025-09-03-10-03-04.png)

##=# [도전] Left Shift(<<)를 이용한 프로그래밍
- **반복문**을 이용하여 아래와 같이 출력
- Loop 1: 0b1 출력 (2진수와 10진수로 출력)
- Loop 2: 0b10 출력 (2진수와 10진수로 출력)
- Loop 3: 0b100 출력 (2진수와 10진수로 출력)
- Loop 4: 0b1000 출력 (2진수와 10진수로 출력)
- Loop 5: 0b10000 출력 (2진수와 10진수로 출력)

![0903_시작하기_2025-09-03-10-04-46](images/0903_시작하기_2025-09-03-10-04-46.png)

### 비트 연산 응용 1
- 1 << n
    - 2^n 의 값을 갖음
    - 임베디드 분야에서 계산을 빠르게 하기 위해 사용됨

### 비트 연산 응용 2
- i & (1 << n)
    - i의 n번째 비트가 1인지 아닌지를 확인할 수 있음
    - ex) 1101 & (1 << 2)<br>1101에서 **2번 bit**가 1인지 확인 가능 (결과값 = 0100)<br>결과값이 0보다 크면 n번째 비트는 1임이 확정됨

### 음수 표현 방법
- 컴퓨터는 음수를 <b>"2의 보수"</b>로 관리함<br>맨 앞자리 bit(**MSB**)는 음수 or 양수를 구분하는 비트임
- 컴퓨터가 2의 보수를 사용하여 음수를 관리하는 이유
    - 뺄셈의 연산 속도를 올릴 수 있으며, +0과 -0을 따로 취급하지 않기 위해 사용

```py
def bit_print(i):
    output = ''
    for j in range(7, -1, -1):
        output += '1' if i & (1 << j) else '0'
    print(output)

for i in range(-5, 6):
    print(f'{i} = ", end='')
    bit_print(i)
```

![0903_시작하기_2025-09-03-10-27-30](images/0903_시작하기_2025-09-03-10-27-30.png)

### 2의 보수 예시
- 10001 의 2의 보수
    - 수를 모두 뒤집고 +1
    - 01110 + 1 = 01111

- 1111000 의 2의 보수
    - 수를 뒤집으면 0000111
    - 0000111 + 1 = 0001000

### 신기한 2의 보수
- 2의 보수를 취한 수를, 한 번 더 2의 보수를 취하면 **원래의 값으로 돌아옴**
- 10001 의 2의 보수
    - 수를 모두 뒤집고 +1
    - 01110 + 1 = 01111
- **01111** 의 2의 보수
    - 10000 + 1 = 10001

### -5를 2의 보수로 표현하는 방법 (가정: 수를 8-bit로 저장하는 경우)
- 수 5를 2진수로 나타내면 0000 0101 (7-bit)
- -5는 음수이기에 MSB는 1
- 나머지 7-bit에 대해, 수를 뒤집고 1을 더함 (2의 보수)
- 수 5를 뒤집으면 111 1010 이며, 1을 더하면 111 1011이 됨
- **따라서 1111 1011 이 됨**

### biswise NOT(complement) 연산자
- ~ 연산자: 모든 비트를 반전시킴
- 만약 8-bit일 때 ~(0001 1111) 이라면 값은 1110 0000 이 됨

### Bitwise NOT 연산자를 파이썬에서 수행하기
- 파이썬에서는 ~4를 수행하면 -5가 출력됨
- 파이썬이 ~4를 -5로 출력하는 과정
    - 4는 0b0100 (MSB: 0)
    - NOT 연산자로 인해 뒤집으면 1011
    - MSB는 1이 되었고, 나머지 bit는 011
    - 나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101 이므로 5가 된다.
    - 따라서 -5가 된다.

![0903_시작하기_2025-09-03-10-35-52](images/0903_시작하기_2025-09-03-10-35-52.png)

### [도잔] 비트연산 문제 풀어보기 (SWEA 10726. 이진수 표현)
- 정수 N, M이 주어질 때, M의 이진수 표현의 마지막 N 비트가 모두 1로 켜져 있는지 아닌지를 판별하여 출력, 모두 켜져 있다면 ON 출력, 아니면 OFF 출력
- ex) 5 31<br>31은 이진수로 000**1 1111**<br>5개 bit가 모두 1로 켜져 있음<br>따라서 정답은 "ON"

## 실수

### 파이썬에서 실수 출력 방법
- 파이썬은 f-string 문법을 지향

```py
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다') # 변수 값은 10 입니다
print(f'변수 값은 {t2} 입니다') # 변수 값은 3.141592 입니다
```

### 소수점 출력 방법
- {t2:.2f}: t2 값을 소수점 셋째자리에서 **반올림**하여 표현

```py
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다') # 변수 값은 10 입니다
print(f'변수 값은 {t2:.2f} 입니다') # 변수 값은 3.14 입니다
```

### 파이썬에서의 실수 표현 범위
- 파이썬에서는 64비트 부동소수점으로 실수를 표현함
    - 15~17자리 정밀도와 +- 1.8e308 범위를 가짐
- 최대로 표현할 수 있는 값은 약 1.8 * 10^**308** 이고 이 이상은 inf로 표현<br>(참고로 1억은 1 * 10^8 임)
- 최소로 표현할 수 있는(0에 가장 가까운) 값은 약 5.0 * 10^**-324** 이며, 이 이하는 0으로 표현

### 컴퓨터는 실수를 내부적으로 근사적으로 관리
- 실수는 정확한 값이 아니라 근삿값으로 저장되는데 이 때 **생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴**

```py
print(0.1 + 0.1 + 0.1 == 0.3)   # False
```

### [도전] 실수 값 출력해보기
- 0.1이 정확히 어떤 값으로 저장되었는지, f-string 을 이용하여 출력
- **소수점 20자리 이상으로도** 출력

```py
t = 0.1
print(f'{t:.2f}')   # 0.10
```

### 소수점이 있는 10진수를 2진수로 변환 예시
- 0.75 = 2^**-1** + 2^**-2**<br>= 0. 11_(2)
- 0.40625 = 2^**-2** + 2^**-3** + 2^**-5**<br>
= 0.0**11**0**1**_(2)

![0903_시작하기_2025-09-03-10-54-25](images/0903_시작하기_2025-09-03-10-54-25.png)

### 소수점을 포함한 2진 실수를 10진수로 변환하는 예시
- 예) 1001.**0011**

![0903_시작하기_2025-09-03-10-55-00](images/0903_시작하기_2025-09-03-10-55-00.png)

### 실수의 표현
- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용<br>이 표기법은 **IEEE 754** 라는 컴퓨터에서 부동 소수점을 표기하는 국제표준임
- **부동** 소수점 표기 방법은 **소수점의 위치를 고정시켜** 표현하는 방식임.
- 소수점의 위치를 왼쪽의 가장 유혀한 숫자 다음으로 고정시키고 밑 수의 지수승으로 표현

![0903_시작하기_2025-09-03-10-56-21](images/0903_시작하기_2025-09-03-10-56-21.png)

### 실수를 저장하기 위한 형식 (IEEE 754, 32bits - Single Precision 표기법 기준)
- 32-bit 구조

![0903_시작하기_2025-09-03-10-57-53](images/0903_시작하기_2025-09-03-10-57-53.png)

- 부호 1비트: 0이면 양수, 1이면 음수
- 지수부(exponent): 부동 소수점의 크기 + bias 값
- 가수부(mantissa): 실질적 수

### 12.375 를 부동 소수점으로 표기
- 12.375를 2진수로 변환: 12는 1100, 0.375sms 0.011이므로 **1100.011**
- **1100.011** = 1.**100011** * 2^3<br>
즉, 가수는 **100011**이고, 지수는 3 (맨 앞 1은 생략)

### 지수 + bias: IEEE 754는 bias를 더한 결과로 표기
- 3 + 127(bias) = 130 (2진수로는 **10000010)

### 12.375 를 IEEE 754 로 표기하는 방법
- 부호 비트: 0 (양수)
- 지수: **10000010**
- 가수: **100011**00000000000000000

### 컴퓨터는 **실수를 근사적으로 표현**
- 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근삿값으로 저장되는데, 이 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴

### 실수 자료형의 유효 자릿수
- 32 비트 실수형 유효자릿수(10진수) -> 약 6 자리 (C/C++, Java)
- 64 비트 실수형 유효자릿수(10진수) -> 약 15 자리 (C/C++, Java, Python)

## 연습 문제

### 16진수 문자로 이루어진 1차 배열이 주어질 때 앞에서부터 7-bit씩 묶어 10진수로 변환하여 출력하기
- 예를 들어<br>
![0903_시작하기_2025-09-03-11-58-20](images/0903_시작하기_2025-09-03-11-58-20.png)<br>
일 경우, 2진수로 변환하면<br>
0000**1111**1001**0111**1010**0011** 이고, 이를 7-bit씩 묶으면<br>
**0000111**1100101**1110100**011 이므로, 출력 결과는 7, 101, 116, 3이다.
- 예시
    - 입력: 01D06079861D79F99F<br>
    정답: 14 65 64 121 67 7 47 31 76 31

```py
for i in range(0, N, 7):
    # i번 비트에서 7칸 잘라서 십진수로 만들고 출력
    ith_bin = bin[i:i+7]

    # 십진수로 바꾸기
    decimal = 0
    
    for n in range(6, -1, -1):
        decimal += int(ith_bin[n]) * 2**(6 - n)
