# 컴퓨팅 사고력

## 프로그래밍과 논리/수학

### 논리(Hard Logic)의 정의
- 생각이나 주장의 타당성과 옳고 그름을 판별하는 규칙이나 원리를 의미
- 경험적, 직관적, 확률적 판단을 의미하는 soft logic에 반대되는 의미로 hard logic이라고 표현
- 맞는 이유와 틀린 이유를 정확히 밝히는 생각의 규칙

### 프로그래밍의 어려운 점
- 프로그래밍 언어 문법과 라이브러리 사용
    - 처음 보는 사람은 알 수 없음
    - 훈련에 비례하여 실력 향상
- 논리
    - 직관적인 접근을 논리로 착각하기 쉬움

### 카드 문제
- 직관으로 접근하면 어려운 문제
- 사실: 모든 카드의 한 쪽에는 알파벳이, 다른 쪽에는 숫자가 써 있음
- 주장: 한 쪽이 D이면 반대쪽은 3
- 주장이 사실인지 확인하기 위해 다음 카드들 중 반드시 뒤집어 보아야 하는 것은 몇 개이고 어느 것인가?

![0901_컴퓨팅_사고력_2025-09-07-23-08-34](images/0901_컴퓨팅_사고력_2025-09-07-23-08-34.png)

- 답: [D]와 [7]
- [D]를 뒤집어 보아야 한다는 것은 누구나 알아냄
- [3]을 뒤집어 보아야 한다고 말하는 경우가 많이 있음
    - 그러나 [3] 뒤에 [D]가 있든 없든 주장이 사실인지 여부에 영향이 없음
- [7]을 뒤집어 볼 필요가 없다고 말하는 경우도 많음
    - 그러나 [7] 뒤에 [D]가 있으면 주장이 성립하지 않음

### 맥주집 문제
- 규칙: 20세 이하인 사람은 맥주를 마실 수 없음
- 나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 몇 명이고 누구인가?
    - 답: [17세]와 [맥주]

### 카드 문제와 맥주집 문제의 비교
- 맥주집 문제가 훨씬 풀기 쉽다
    - 사실, 두 문제는 완전히 같은 문제. 즉, 논리적 구성이 완전히 동일
- 왜 맥주집 문제가 풀기 쉬운가?
    - 논리 구조를 정확히 이해하고 맥주집 문제를 푸는 사람은 카드 문제를 똑같이 풀 수 있다.
    - 맥주집 문제를 풀 때 논리를 사용한 것이 아님

### Soft Logic
- 맥주집 문제를 풀 때 직관을 사용한 것과 같은 경우
- 직관은 논리적인 느낌을 주는 것
- 직관의 장점은 익숙한 상황에서 빠름
- 직관의 단점은 정확하지 않음 (가끔은 익숙한 상황에서도 틀림)
- 또 다른 단점은 강한 착각을 일으킨다는 것

### Hard Logic vs Soft Logic
- 일상 생활
    - Soft Logic이 빠르기 때문에 유용함
    - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재
- 프로그래밍
    - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
    - 사용되는 수 많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요
- 문제에 대해 오해하는 경우
    - Soft Logic으로 알고리즘을 이해하려고 하는 경우
    - 알고리즘 설명을 보고 또 봐도 이해가 안 되는 것은 증명을 안 봤기 때문
    - 증명을 봐도 이해가 안 되는 것은 직관으로 이해하려고 하기 때문
    - 가끔 직관적으로 이해되는 알고리즘이 있지만, 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능

### 명제
- 참이나 거짓을 알 수 있는 식이나 문잔
- p, q, r, ...로 표현
- 예) 서울은 대한민국의 수도다.<br>1+1=3
- 진릿값
    - 참이나 거짓을 표현
    - T, F 또는 1, 0
    - 예) p가 거짓 (F), q가 참 (T)

### 명제의 연산(결합)
- 부정 (NOT)
    - p가 명제일 때, 명제의 진릿값이 반대가 됨
    - ~p 또는 ￢p로 표기하고 not p 또는 p의 부정으로 읽음
- 논리곱 (AND)
    - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
    - p ^ q로 표기하고, p and q 또는 p 그리고 q로 읽음

![0901_컴퓨팅_사고력_2025-09-07-23-17-53](images/0901_컴퓨팅_사고력_2025-09-07-23-17-53.png)

- 논리합 (OR)
    - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
    - p V q로 표기하고 p or q나 p 또는 q로 읽음

![0901_컴퓨팅_사고력_2025-09-07-23-18-34](images/0901_컴퓨팅_사고력_2025-09-07-23-18-34.png)

- 배타적 논리합 (XOR)
    - p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제
    - p ⊕ q로 표기하고 p xor q 또는 p exclusive OR q로 읽음

![0901_컴퓨팅_사고력_2025-09-07-23-22-20](images/0901_컴퓨팅_사고력_2025-09-07-23-22-20.png)

### 조건명제
- p, q가 명제일 때, 명제 p가 조건(원인), q가 결론(결과)으로 제시되는 명제
- p -> q (p이면 q이다)

![0901_컴퓨팅_사고력_2025-09-07-23-23-00](images/0901_컴퓨팅_사고력_2025-09-07-23-23-00.png)

### 쌍방조건명제
- p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
- p <-> q (p면 q고, q면 p다)

![0901_컴퓨팅_사고력_2025-09-07-23-23-37](images/0901_컴퓨팅_사고력_2025-09-07-23-23-37.png)

### 조건 명제의 역, 이, 대우
- 주어진 명제: p -> q
- 역: q -> p
- 이: ~p -> ~q
- 대우: ~q -> ~p

![0901_컴퓨팅_사고력_2025-09-07-23-24-18](images/0901_컴퓨팅_사고력_2025-09-07-23-24-18.png)

### 문제 1: 다음을 명제식 형태로 쓰고 참인지 거짓인지 판단하시오

![0901_컴퓨팅_사고력_2025-09-07-23-25-24](images/0901_컴퓨팅_사고력_2025-09-07-23-25-24.png)

### 문제 2: p와 q가 명제이고 p -> q가 거짓이라고 하자. 다음 명제식의 참 거짓은 어떻게 되는가?

![0901_컴퓨팅_사고력_2025-09-07-23-25-49](images/0901_컴퓨팅_사고력_2025-09-07-23-25-49.png)

### 문제 3: 다음 명제들의 역, 이, 대우를 쓰시오

![0901_컴퓨팅_사고력_2025-09-07-23-26-02](images/0901_컴퓨팅_사고력_2025-09-07-23-26-02.png)

### 문제 4: 다음 명제식의 진리표를 만드시오

![0901_컴퓨팅_사고력_2025-09-07-23-26-20](images/0901_컴퓨팅_사고력_2025-09-07-23-26-20.png)

![0901_컴퓨팅_사고력_2025-09-07-23-26-25](images/0901_컴퓨팅_사고력_2025-09-07-23-26-25.png)

### 증명
- 직접 증명
    - p -> q가 참임을 증명하기 위해 p를 참으로 가정했을 때 q도 참임을 증명하는 방법
    - Trivial Proof(자명한 증명)
    - Vacuous Proof(공허한 증명)
- 간접 증명
    - 증명해야 하는 명제를 변형하여 증명하는 방법
    - 대우에 의한 증명
    - 모순에 의한 증명
- 수학적 귀납법
    - 일정한 규칙을 나타내는 명제 P(n)이 성립함을 증명하는 방법

### Trivial Proof: ∀x, P(x) -> Q(x)를 증명하려는데, Q(x)가 항상 참인 경우

![0901_컴퓨팅_사고력_2025-09-07-23-29-17](images/0901_컴퓨팅_사고력_2025-09-07-23-29-17.png)

### Vacuous Proof: ∀x, P(x) -> Q(x)를 증명하려는데, P(x)가 항상 거짓인 경우

![0901_컴퓨팅_사고력_2025-09-07-23-29-38](images/0901_컴퓨팅_사고력_2025-09-07-23-29-38.png)

### 수학적 귀납법과 증명의 수준
- 0보다 크거나 같은 정수 범위에 대해 P(n)이 성립함을 증명
    - 수학적 귀납법의 기본형: P(1)이 참이고, P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대하여 참이다.
    - 수학적 귀납법의 강한 형태: P(1)이 참이고, P(1) ^ P(2) ^ ... ^ P(n) ^ P(n+1)이 참이면 P(n)은 모든 자연수 n에 대하여 참이다.
- 다음 함수가 1부터 x까지의 합을 계산함을 증명한다면

```py
def sum(x):
    if (x <= 0):
        return 0
    return x + sum(x-1)
```

- 상세한 증명을 하려면 단순히 "답이 맞는 것이 당연하다"라고 말하는 것으로는 충분하지 않음
    - 증명이 가능한 명제를 만들어야 함
    - 이 경우 증명이 가능한 명제는 다음과 같음: "sum(x)가 리턴하는 값은 1+2+...+x의 값과 항상 같다"
    - 이제 수학적 귀납법을 적용할 수 있음
    - P(1)이 참이다: "sum(1)이 리턴하는 값은 1이다"를 증명하면 됨. 실제 코드에 1을 대입하면 1을 리턴함을 알 수 있음.

```
sum(1)
    if(x <= 0) return 0
    return 1 + sum(0)
```

- 임의의 값 k에 대해 P(k)가 참이라고 가정: sum(k)가 1 + 2 + ... + k를 리턴
- k + 1에 대해 P(k+1)이 참이라고 증명

    ```
    sum(k + 1)
        if (k + 1 <= 0) return 0
        return k + 1 + sum(k)
    ```

    - sum(k)는 1 + 2 + ... + k 라고 가정했으므로, sum(k + 1) = 1 + 2 + ... + k + 1을 리턴. P(k + 1)이 참
    - 따라서 sum(x)는 1에서 x까지의 합을 리턴

## 논리와 증명

### 문제 1: 다음 명제들이 <u>항진명제</u>라는 것을 진리표를 이용해서 보이시오.

![0901_컴퓨팅_사고력_2025-09-07-23-36-53](images/0901_컴퓨팅_사고력_2025-09-07-23-36-53.png)

![0901_컴퓨팅_사고력_2025-09-07-23-37-02](images/0901_컴퓨팅_사고력_2025-09-07-23-37-02.png)

### 문제 2: 다음 명제들이 <u>모순명제</u>라는 것을 진리표를 이용해서 보이시오.

![0901_컴퓨팅_사고력_2025-09-07-23-37-40](images/0901_컴퓨팅_사고력_2025-09-07-23-37-40.png)

![0901_컴퓨팅_사고력_2025-09-15-00-32-02](images/0901_컴퓨팅_사고력_2025-09-15-00-32-02.png)

### 문제 3: 다음 명제의 쌍들에 대해 두 명제가 동등한지를 진리표를 이용해 확인하시오.

![0901_컴퓨팅_사고력_2025-09-15-00-32-22](images/0901_컴퓨팅_사고력_2025-09-15-00-32-22.png)

![0901_컴퓨팅_사고력_2025-09-07-23-38-12](images/0901_컴퓨팅_사고력_2025-09-07-23-38-12.png)

### 문제 4: 명제식의 변형을 통하여 다음 명제를 간소화하시오.

![0901_컴퓨팅_사고력_2025-09-15-00-33-22](images/0901_컴퓨팅_사고력_2025-09-15-00-33-22.png)

### 문제 5: 다음 명제들이 참인지 확인하시오. (단, R은 실수의 집합, Z는 정수의 집합)

![0901_컴퓨팅_사고력_2025-09-07-23-38-56](images/0901_컴퓨팅_사고력_2025-09-07-23-38-56.png)

![0901_컴퓨팅_사고력_2025-09-15-00-33-41](images/0901_컴퓨팅_사고력_2025-09-15-00-33-41.png)

### 문제 6: n이 짝수이면 3n + 5는 홀수임을 증명하라

![0901_컴퓨팅_사고력_2025-09-07-23-41-18](images/0901_컴퓨팅_사고력_2025-09-07-23-41-18.png)

### 문제 7: n이 홀수이면 n ** 2 + n은 짝수임을 증명하라

![0901_컴퓨팅_사고력_2025-09-15-00-35-38](images/0901_컴퓨팅_사고력_2025-09-15-00-35-38.png)

### 문제 8: m이 짝수이고 n이 홀수이면 2m + 3n은 홀수임을 증명하라

![0901_컴퓨팅_사고력_2025-09-07-23-42-06](images/0901_컴퓨팅_사고력_2025-09-07-23-42-06.png)

### 문제 9: (대우를 증명) 자연수 n에 대해, n ** 2 + 5가 홀수이면 n은 짝수임을 증명하라

![0901_컴퓨팅_사고력_2025-09-07-23-42-23](images/0901_컴퓨팅_사고력_2025-09-07-23-42-23.png)

### 문제 10: n ** 2이 짝수이면 n은 짝수임을 증명하라

![0901_컴퓨팅_사고력_2025-09-15-00-34-31](images/0901_컴퓨팅_사고력_2025-09-15-00-34-31.png)

### 문제 11: (경우를 나누어 증명) 자연수 n에 대해 n ** 2 + 5 * n + 3은 항상 홀수임을 증명하라.

![0901_컴퓨팅_사고력_2025-09-07-23-42-52](images/0901_컴퓨팅_사고력_2025-09-07-23-42-52.png)

### 문제 12: n^2이 3의 배수이면 n은 3의 배수임을 증명하라

```md
Proof)
대우: n이 3의 배수가 아니면 n^2는 3의 배수가 아니다.
1. n = 3k + 1 일 때, 
    n^2 = 9k^2 + 6k + 1
        = 3(3k^2 + 2k) + 1 이므로 3의 배수가 아니다.

2. n = 3k + 2 일 때,
    n^2 = 9k^2 + 12k + 4
        = 3(3k^2 + 4k + 1) + 1 이므로 3의 배수가 아니다.

대우가 참이므로, n^2이 3의 배수이면 n은 3의 배수이다.
```

## 수와 표현

### 약간의 설명
- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2 ** k - 1까지 표현 가능
- 사실 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 최대 2 ** k 가지의 값을 표현하는 것이 가능
- 10진수로 k자리를 쓰면 0부터 10 ** k - 1까지 표현이 가능한 것과 완전히 동일한 과정
- 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
    - 2 ** k - 1 >= n이 성립해야 한다. -> 즉, 2 ** k >= n + 1
    - 같은 의미로, k >= log (n + 1) -> 약 log n 비트가 필요
- x = log n 과 2 ** x = n 은 같은 말

### log n 이란
- 2의 몇 승이 n이 되는가의 답
- n을 표현하는데 몇 비트가 필요한가의 답
- 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되는가의 답
- n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되는가에 대한 답
- x = log n 일 때 x와 n을 비교하면 x가 더 작고, n이 커질 수록 엄청나게 달라짐
    - 100자리 n은 읽을 수도 없을 정도로 큰 값이지만 x는 작은 값
- 컴퓨터 분야에서 로그의 밑은 항상 2
- 32비트 컴퓨터의 주소 공간은 2 ** 32 = 약 42억 개
- n + (n / 2 + n / 2) + (n / 4 + n / 4 + n / 4 + n / 4) + ... + (1 + 1 + ... + 1) ≒ n log n
- n + n / 2 + n / 4 + ... + 1 ≒ 2n
- 위 두 식에서 항의 개수는 log n개
    - 분모를 2 ** k로 나타내면, 1 = n / 2 ** k, 2 ** k = n 이므로 k = log n

### 문제 1: 2진수 표현에서 log n 비트로 표현할 수 있는 숫자 범위는?
- n비트로 표현할 수 있는 숫자는 2 ** n가지
- log n 비트로 표현할 수 있는 숫자는 n가지

### 문제 2: 스무고개가 이상적으로 진행된다고 할 때, 맞출 수 있는 답의 종류는 몇 가지인가?
- 2 ** 20 = 1048576가지

### 문제 3: n이 충분히 큰 값일 때 다음 중 어느 값이 더 큰가? 각 쌍에 대해 비교하고 그 이유를 작성하시오

![0901_컴퓨팅_사고력_2025-09-07-23-51-15](images/0901_컴퓨팅_사고력_2025-09-07-23-51-15.png)

![0901_컴퓨팅_사고력_2025-09-07-23-51-24](images/0901_컴퓨팅_사고력_2025-09-07-23-51-24.png)

### 문제 4: x = log_a yz일 때 x를 2를 밑으로 하는 로그들로 표현하시오. 단, 로그 함수의 인자는 모두 문자 하나여야 한다.

![0901_컴퓨팅_사고력_2025-09-07-23-52-18](images/0901_컴퓨팅_사고력_2025-09-07-23-52-18.png)

### 문제 5: 다음 함수들의 역함수를 구하시오

![0901_컴퓨팅_사고력_2025-09-15-00-37-55](images/0901_컴퓨팅_사고력_2025-09-15-00-37-55.png)

## 집합과 조합론

### 집합과 조합론에 대한 약간의 설명
- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
- 예를 들어 모든 4의 배수는 2의 배수라는 것을 증명하려면, 4k = 2 * (2k) 임을 보이면 되는 것이다.
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 된다.

### 다음 두 집합이 같다는 것을 상세히 증명

- A = {x|x=2k+1, k는 자연수}, B = {x|x=4k+1 혹은 x=4k+3, k는 자연수}
- A가 B의 부분집합이다:
    - A에 포함되는 임의의 원소 x를 가정
    - x = 2k + 1
    - k가 짝수(=2t)인 경우와 홀수(=2t+1)인 경우로 나눔
    - 짝수인 경우 x=2k+1=2(2t)+1=4t+1로서, x는 B에 포함됨
    - 홀수인 경우 x=2k+1=2(2t+1)+1=4t+3로서, x는 B에 포함됨
    - 모든 가능한 경우에 x는 B에 포함됨
- B가 A의 부분집합이다:
    - B에 포함되는 임의의 원소 x를 가정
    - x=4k+1인 경우, x=4k+1=2(2k)+1로서 x는 A에 포함됨
    - x=4k+3인 경우, x=4k+3=2(2k+1)+1로서 x는 A에 포함됨
    - 모든 가능한 경우에 x는 B에 포함됨
- 위 두 가지 증명에서 집합 A와 B는 같다

### 조합론

![0901_컴퓨팅_사고력_2025-09-07-23-54-18](images/0901_컴퓨팅_사고력_2025-09-07-23-54-18.png)

### 문제 1

![0901_컴퓨팅_사고력_2025-09-15-00-48-02](images/0901_컴퓨팅_사고력_2025-09-15-00-48-02.png)

### 문제 2

![0901_컴퓨팅_사고력_2025-09-07-23-54-47](images/0901_컴퓨팅_사고력_2025-09-07-23-54-47.png)

![0901_컴퓨팅_사고력_2025-09-07-23-54-53](images/0901_컴퓨팅_사고력_2025-09-07-23-54-53.png)

![0901_컴퓨팅_사고력_2025-09-07-23-55-16](images/0901_컴퓨팅_사고력_2025-09-07-23-55-16.png)

### 문제 3: 위의 결과를 이용해서 n개의 원소를 가진 집합의 가능한 부분집합의 종류는 2 ** n개임을 증명하라

![0901_컴퓨팅_사고력_2025-09-15-00-48-58](images/0901_컴퓨팅_사고력_2025-09-15-00-48-58.png)

### 문제 4

![0901_컴퓨팅_사고력_2025-09-07-23-55-24](images/0901_컴퓨팅_사고력_2025-09-07-23-55-24.png)

![0901_컴퓨팅_사고력_2025-09-07-23-55-51](images/0901_컴퓨팅_사고력_2025-09-07-23-55-51.png)

### 문제 5: 다음이 사실임을 증명하라

![0901_컴퓨팅_사고력_2025-09-15-00-51-25](images/0901_컴퓨팅_사고력_2025-09-15-00-51-25.png)

### 문제 6: 8 x 8 체스 판에 말 두 개를 놓으려한다. 아무 곳에나 놓아도 되지만 한 칸에 두 개가 들어가지는 못 한다. 가능한 방법은 모두 몇 가지인가?

![0901_컴퓨팅_사고력_2025-09-07-23-56-23](images/0901_컴퓨팅_사고력_2025-09-07-23-56-23.png)

### 문제 7: 비밀번호를 0부터 9까지의 숫자만 가지고 만든다고 하자. 4개 이상 6개 이하의 숫자를 쓸 수 있다고 할 때 가능한 비밀번호의 가지수는 얼마인가?

![0901_컴퓨팅_사고력_2025-09-15-00-53-49](images/0901_컴퓨팅_사고력_2025-09-15-00-53-49.png)

### 문제 8: 52개의 카드를 이용해서 만들 수 있는 5개 카드의 조합은 몇 가지인가?

![0901_컴퓨팅_사고력_2025-09-07-23-57-12](images/0901_컴퓨팅_사고력_2025-09-07-23-57-12.png)

### 문제 9: 52개의 카드를 이용해서 만들 수 있는 5개 카드 조합 중 같은 무늬의 카드가 정확히 3개인 경우는 몇 가지인가?

![0901_컴퓨팅_사고력_2025-09-07-23-57-54](images/0901_컴퓨팅_사고력_2025-09-07-23-57-54.png)

### 문제 10: x + y + z = 100의 자연수 해는 몇 가지인가?

![0901_컴퓨팅_사고력_2025-09-07-23-58-18](images/0901_컴퓨팅_사고력_2025-09-07-23-58-18.png)

### 문제 11: 52개 카드에서 5개 카드 조합을 만들 때, 숫자가 같은 카드가 한 쌍도 없는 경우는 몇 가지인가?

![0901_컴퓨팅_사고력_2025-09-15-00-54-14](images/0901_컴퓨팅_사고력_2025-09-15-00-54-14.png)

## 기초수식

### 약간의 설명
- 알고리즘의 시간 복잡도를 표현할 수 있는 다양한 수식들이 존재
- 풀이법을 익혀 두어야 알고리즘의 시간 복잡도를 계산할 수 있고, 알고리즘이 얼마나 시간이 걸릴 지 예측할 수 있음
- 재귀식을 O() notation 수준으로 풀어보는 연습이 필요

### 문제 1: T(n) = T(n - 1) + 1, T(0) = 1

![0901_컴퓨팅_사고력_2025-09-07-23-59-31](images/0901_컴퓨팅_사고력_2025-09-07-23-59-31.png)

### 문제 2: T(n) = T(n - 1) + n, T(0) = 1

![0901_컴퓨팅_사고력_2025-09-08-00-00-17](images/0901_컴퓨팅_사고력_2025-09-08-00-00-17.png)

### 문제 3: T(n) = T(n - 1) + log n, T(0) = 1

![0901_컴퓨팅_사고력_2025-09-15-00-55-12](images/0901_컴퓨팅_사고력_2025-09-15-00-55-12.png)

### 문제 4: T(n) = T(n / 2) + 1, T(1) = 1

```md
T(n) = T(n / 2) + 1
     = T(n / 2^2) + 1 + 1
     = T(n / 2^k) + k
     = T(1) + logn, n == k

O(T(n)) = O(logn)
```

### 문제 5: T(n) = T(n / 2) + n, T(1) = 1

![0901_컴퓨팅_사고력_2025-09-08-00-01-03](images/0901_컴퓨팅_사고력_2025-09-08-00-01-03.png)

### 문제 6: T(n) = 2 * T(n / 2) + n, T(1) = 1

![0901_컴퓨팅_사고력_2025-09-15-00-55-50](images/0901_컴퓨팅_사고력_2025-09-15-00-55-50.png)

### 문제 7: T(n) = 3 * T(n / 2) + n, T(1) = 1

![0901_컴퓨팅_사고력_2025-09-08-00-01-49](images/0901_컴퓨팅_사고력_2025-09-08-00-01-49.png)

### 문제 8: T(n) = T(n - 1) + 1 / n, T(1) = 1

![0901_컴퓨팅_사고력_2025-09-15-00-56-12](images/0901_컴퓨팅_사고력_2025-09-15-00-56-12.png)

## 재귀

### 약간의 설명
- 재귀란 자기 자신을 호출하는 함수, 그럼 끝날 수가 있는가?
- 함수는 입력이 있으며, 자기 자신의 입력과 동일한 입력으로 자기 자신을 호출하면 당연히 끝나지 않음
- 하지만, 다른 입력으로 호출하면 끝날 수 있음

```py
def abc(x):         # 이 함수는 안 끝남
    return abc(x)

def sum(x):         # 이 함수는 끝남. 결과값은?
    if (x <= 0):
        return 0
    return x + sum(x - 1)
```

- 함수란 어떤 문제를 해결하는 방법을 코딩한 것
- 함수가 어떤 문제의 단 한 케이스만을 해결하는 것이 아님
- 제대로 코딩된 것이라면 해결하는 문제의 모든 케이스들을 해결해야 함
- 수학적 귀납법 증명 사용 가능
    - (가) n이 0일 때 문제를 풀 수 있음
    - (나) n - 1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있다
    - 위 두 가지가 사실이면 모든 가능한 n에 대해 문제를 풀 수 있다는 것이 사실
- 위 박스의 함수 sum()을 보면 정확히 앞의 두 가지를 코딩한 것임
- 따라서, sum() 함수는 문제를 해결한다는 것을 증명할 수 있음
- 방금 보인 증명은 high-level 증명이며, 상세한 증명은 앞에서 본 적이 있음
- 어떤 미스터리한 이유로 문제가 해결되는 것은 아니고, 실제로 프로그램을 돌리면 필요한 계산이 다 일어남. 순차적인 코드에서 일어나는 계산과 완전히 동일. 다만 표현하는 방법이 달라진 것
- 다르게 생각하는 방법
    - 어떤 문제를 해결하려다 부분 문제를 만났는데, 원래 해결하려던 입력 케이스와 동일한 문제에 속하지만 "크기가 더 작은" 입력 케이스를 해결하는 것이 그 부분 문제였다!
    - 즉, 부분 문제가 동일한 문제인 경우

### sum() 함수의 동작

![0901_컴퓨팅_사고력_2025-09-08-00-07-43](images/0901_컴퓨팅_사고력_2025-09-08-00-07-43.png)

### 재귀에 대한 연습
- 재귀 알고리즘을 **슈도코드**로 작성하고, **정확성 증명** 및 **시간 복잡도 계산**을 수행

### 문제 1: 피보나치 수열: F(n) = F(n - 1) + F(n - 2), F(1) = F(2) = 1

![0901_컴퓨팅_사고력_2025-09-08-00-07-51](images/0901_컴퓨팅_사고력_2025-09-08-00-07-51.png)

![0901_컴퓨팅_사고력_2025-09-08-00-08-03](images/0901_컴퓨팅_사고력_2025-09-08-00-08-03.png)

### 문제 2: Merge Sort

![0901_컴퓨팅_사고력_2025-09-08-00-08-07](images/0901_컴퓨팅_사고력_2025-09-08-00-08-07.png)

![0901_컴퓨팅_사고력_2025-09-15-00-58-07](images/0901_컴퓨팅_사고력_2025-09-15-00-58-07.png)

### 문제 3: 다음 소팅 알고리즘이 실제로 소팅에 항상 성공한다는 것을 증명하라

![0901_컴퓨팅_사고력_2025-09-08-00-08-32](images/0901_컴퓨팅_사고력_2025-09-08-00-08-32.png)

![0901_컴퓨팅_사고력_2025-09-08-00-08-36](images/0901_컴퓨팅_사고력_2025-09-08-00-08-36.png)

![0901_컴퓨팅_사고력_2025-09-15-00-58-43](images/0901_컴퓨팅_사고력_2025-09-15-00-58-43.png)

### 문제 4: 문제 3 소팅 알고리즘에서 수행하는 Swap의 횟수는 최대 몇 번인가?

![0901_컴퓨팅_사고력_2025-09-08-00-09-02](images/0901_컴퓨팅_사고력_2025-09-08-00-09-02.png)

## 동적 계획법

### 약간의 설명
- 간단하게 설명하면 재귀 함수에서 동일한 입력의 함수 호출이 반복적으로 일어날 때 그 결과값을 저장해두고 불러 쓰는 것(Memoization)
- 최초 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 함
- 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과값을 순서를 정해서 계산할 수 있음(Dynamic Programming)
- 동적 계획법 알고리즘을 슈도코드로 작성하고, 정확성 증명 및 시간 복잡도를 계산하는 연습이 필요

### 문제 1: Memoization 피보나치 수열: F(n) = F(n - 1) + F(n - 2), F(1) = F(2) = 1

![0901_컴퓨팅_사고력_2025-09-15-00-59-28](images/0901_컴퓨팅_사고력_2025-09-15-00-59-28.png)

### 문제 2: Dynamic Programming 피보나치 수열: F(n) = F(n - 1) + F(n - 2)

![0901_컴퓨팅_사고력_2025-09-08-00-11-32](images/0901_컴퓨팅_사고력_2025-09-08-00-11-32.png)

![0901_컴퓨팅_사고력_2025-09-08-00-11-43](images/0901_컴퓨팅_사고력_2025-09-08-00-11-43.png)

### 문제 3

![0901_컴퓨팅_사고력_2025-09-15-01-00-09](images/0901_컴퓨팅_사고력_2025-09-15-01-00-09.png)

### 실습
- 논리와 증명
    - 문제 12
- 기초수식
    - 문제 4
