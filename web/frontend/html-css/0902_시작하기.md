# 시작하기

## SW 문제해결

### SW 문제해결 역량이란?
- 프로그래밍을 하기 위한 많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력
- **프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력**
- 문제해결 역량은 추상적인 기술임
    - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없음
    - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않음
- **문제해결 역량을 향상시키기 위해 훈련이 필요함**

### 문제해결 과정
1. 문제를 읽고 <mark>이해</mark>한다.
2. 문제를 익숙한 용어로 <mark>재정의</mark>한다.
    - ex)나만의 언어로 주석을 달아본다.
3. 어떻게 해결할지 <mark>계획</mark>을 세운다.
    - 자료구조, 알고리즘 선택
4. <mark>계획을 검증</mark>한다..
    - 복잡도 고려
5. 프로그램으로 <mark>구현</mark>한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 리스트에 숫자 넣기
- 수 N을 입력받는다.
- 윗 줄에는 N부터 1씩 증가되는 숫자 4개를 왼쪽에 채운다.
- 아랫 줄에는 N부터 1씩 감소되는 숫자 4개를 오른쪽에 채운다.
- 최종 결과를 출력한다. 빈 공간은 0으로 출력한다.

![0902_2025-09-02-09-18-40](images/0902_2025-09-02-09-18-40.png)

### 설계 예시
- 2 * 7 크기의 0으로 채운 리스트를 준비
- 수 N을 입력받음
- t1 = N 대입 후, for문을 4번 돌려 t1 값을 리스트에 넣는다. range(0, 4)
- t2 = N 대입 후, for문을 4번 돌려 t2 값을 리스트에 넣는다. range(6, 2, -1)
- 리스트 출력

![0902_2025-09-02-09-21-35](images/0902_2025-09-02-09-21-35.png)

### SW 문제해결 능력을 기르는 이유
- 코딩을 더 잘하게 하는 능력을 기르기 위함
- SWEA 문제를 통해 기본문법 & 자료구조 & 알고리즘을 더 능숙하게 쓸 수 있도록 훈련함

### SWEA 문제를 잘 풀기 위한 전략
- 단계 1: 완벽한 문제 이해
- 단계 2: 종이와 펜을 이용한 설계 (어떻게 구현할지 계획)
- 단계 3: 설계한 대로 구현 & 디버깅

## 복잡도 분석

### 알고리즘이란?
- 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**
    - 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 간단하게 다시 말하면 어떤 문제를 해결하기 위한 절차라고 볼 수 있음
- 1부터 100까지의 합을 구하는 두 가지 알고리즘의 예

![0902_2025-09-02-09-28-52](images/0902_2025-09-02-09-28-52.png)

### 알고리즘의 효율
- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 알고리즘이 **필요로 하는 메모리 공간**을 말함
    - 시간적 효율성은 알고리즘이 작업을 완료하는데 **걸리는 시간**을 말함
    - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 된다. 복잡도가 높을 수록 효율성은 저하됨

---
**시간적 효율성은 주로 입력 크기 n에 대한 연산 횟수로 표기**

### 복잡도의 접근적 표기
- 시간 (또는 공간)복잡도는 입력 크기에 대한 함수로 표기
    - 이 함수는 주로 여러 개의 항을 가지는 다항식
    - 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
    - **O(Big-Oh) - 표기**: 최악의 케이스 => 개발자로서 신경써야할 표기법
    - Ω(Big-Omega) - 표기: 최선의 케이스
    - Θ(Big-Theta) - 표기: 평균적인 케이스

### 아래 코드는 몇 번 반복될까?

```py
n = int(input())

for i in range(n):
    print(i, end='')
```

### O(Big-Oh) - 표기
- O-표기는 복잡도의 점근적 상한을 나타냄
- 복잡도가 f(n) = 2n^2 - 7n + 4 이라면, f(n)의 O-표기는 O(n^2)
- 먼저 f(n)의 단순화된 표현은 n^2
- 단순화된 함수 n^2에 임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 된다. (단, c>0)

![0902_2025-09-02-09-41-21](images/0902_2025-09-02-09-41-21.png)

### 빅오표기법으로 표현하면?
- O(n)

```py
n = int(input())

for i in range(n):
    print(i, end='')

for i in range(n):
    print(i, end='')
    
for i in range(n):
    print(i, end='')
```

- O(n^2)

```py
n = int(input())

for i in range(n):
    for x in range(n):
        print(i, end='')

    for y in range(n):
        print(i, end='')
```

### 상수 횟수만큼 반복하는 경우 빅오표기법
- O(1)

```py
n = int(input())

for i in range(50):
    print(i)
```

### 빅오표기법 표현 방법
- O(5N)
    - 정확한 배수를 강조하고 싶은 경우라면?
    - O(N)대신 O(5N)으로 표현할 수 있음

```md
예시 : 알고리즘 성능을 미세하게 비교하고 싶은 경우

기존 알고리즘 성능이 O(7N) 이지만,
제가 짠 알고리즘 성능은 O(2N)으로
더 좋은 성능을 냅니다.
```

### 빅오표기법으로 성능 비교하기
- 어떤 알고리즘이 더 좋은 성능을 내는가?

![0902_2025-09-02-09-47-05](images/0902_2025-09-02-09-47-05.png)

> N > 1일 때, O(N)이 더 좋다.

### 자주 사용하는 O-표기
|||
|:-:|:-:|
|O(1)|상수 시간(Constant time)
|**O(logn)**|**로그(대수) 시간(Logarithmic time)**
|O(n)|선형 시간(Linear time)
|**O(nlogn)**|**로그 선형 시간(Log-linear time)**
|O(n^2)|제곱 시간(Quadratic time)
|O(n^3)|세제곱 시간(Cubic time)

### O(N) 이해하기
- 만약 N이 10,000이고 O(N)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까?
    - 정답: 10,000회

### 만약 O(N^2) 라면?
- 만약 N이 10,000이고 O(N^2)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까?
    - 정답: 10,000^2 = 100,000,000회

### 만약 O(log N) 이라면?
- 만약 N이 10,000 이고 O(log N)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까?
    - 약 13.3번
- 컴퓨터 분야에서 log의 밑 수는 10이 아니라 2
    - 2^13 < 10000 < 2^14
---
- 만약 N이 100,000,000 이고 O(log N)으로 짠 알고리즘이 있다면, 몇 번 반복하는 프로그램이라고 추정해도 될까?
- 2의 몇 승이 1억이 되는지 계산기를 통해 알 수 있음
    - 2^26 < 100,000,000 < 2^27

### 복잡도 비교
- O(logN) 은 O(1) 보다는 느리지만, N이 작은 경우 유사한 성능
- O(NlogN) 은 O(N) 보다는 느리지만, N이 작은 경우 유사한 성능

![0902_2025-09-02-10-07-44](images/0902_2025-09-02-10-07-44.png)

### 왜 효율적인 알고리즘이 필요한가?
- 10억 개의 숫자를 정렬하는데 PC에서 O(n^2) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분 만에 정렬함

![0902_2025-09-02-10-08-26](images/0902_2025-09-02-10-08-26.png)

- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음
- 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적임

## 표준 입출력 방법

```py
import sys
sys.stdin = open('input.txt', 'r')
```

# 진법과 연산

## 진법

### 2진수, 8진수, 10진수, 16진수
- **10진수: 사람이 사용하는 진수**, 수 하나를 0 ~ 9 로 표현
- **2진수: 컴퓨터가 사용하는 진수**, 수 하나를 0, 1 로 표현
- 8진수: 2진수를 더 가독성있게 사용
- **16진수: 2진수를 더 가독성있게 사용**, 수 하나를 0, 1, ..., 8, 9, A, B, C, D, E, F로 표현

![0902_2025-09-02-10-47-33](images/0902_2025-09-02-10-47-33.png)

### 왜 16진수를 사용하는 것인가?
- 2진수를 사람이 이해하기 편하도록, 10진수로 변환 시 인간이 이해하기 편하지만, **연산이 오래 걸림**
- 2진수를 사람이 이해하기 편하도록, 16진수로 변환 시 인간이 이해하기 어렵지만, **연산 속도가 매우 빠름**

### 구현 전 계산기 설정

![0902_2025-09-02-10-48-48](images/0902_2025-09-02-10-48-48.png)

### 용어
- HEX: 16진수
- DEC: 10진수
- OCT: 8진수
- BIN: 2진수

## 진법 변환

### 10진수 -> 타 진수로 변환
- 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로 읽음
- 예제) 
    - (149)_10 = (10010101)_2<br>
    = (225)_8<br>
    = (95)_16<br>

![0902_2025-09-02-10-54-06](images/0902_2025-09-02-10-54-06.png)

### 수기로 10진수 -> 2진수로 변환해보기
- 수기로 75를 2진수로 변환하기
- 수기로 14를 2진수로 변환하기
