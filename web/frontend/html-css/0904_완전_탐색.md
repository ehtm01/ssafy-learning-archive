#### 알고리즘은 어떤 순서로 고민해야 할까?
- 완전 탐색
    - 전체 경우를 모두 돌아보는 경우<br>-> 시간 복잡도 이슈<br>+ 가지치기(경우의 수를 줄여보자)
- 규칙 찾기(Greedy)<br>-> 그리디로 해결할 수 없네?
- 동적 계획법(DP)
    - 점화식
- 다른 알고리즘

# 완전 탐색

## 반복과 재귀

### 반복(Iteration)과 재귀(Recursion)는 유사한 작업을 수행할 수 있다.

### 반복은 수행하는 작업이 완료될 때까지 계속 반복
- 루프 (for, while 구조)
- <mark>반복문은 코드를 n번 반복시킬 수 있음</mark>

### 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
- 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합
- <mark>재귀호출은 n 중 반복문과 같은 효과</mark>

### 1, 2, 3으로 만들 수 있는 두 자릿수 만들기
- 2중 for문을 이용하여 구현

```py
for i in range(1, 4):
    for j in range(1, 4):
        print(i, j)
```

```
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
```

### [도전] 1, 2, 3을 이용한 네 자릿수를 출력하는 코드 작성

```
1 1 1 1
1 1 1 2
1 1 1 3
1 1 2 1
1 1 2 2

  ...
3 3 3 2
3 3 3 3
```

```py
for i in range(1, 4):
    for j in range(1, 4):
        for k in range(1, 4):
            for l in range(1, 4):
                print(i, j, k, l)
```

### N을 입력 받아 1, 2, 3을 사용하는 N 자릿수 만들기
- 만약 N = 2 이라면 1 1 ~ 3 3 까지 출력
- 만약 N = 3 이라면 1 1 1 ~ 3 3 3 까지 출력
- 만약 N = 4 이라면 1 1 1 1 ~ 3 3 3 3 까지 출력
- ...
- 만약 N = 9 이라면 1 1 1 1 1 1 1 1 1 ~ 9 9 9 9 9 9 9 9 9 까지 출력

### 재귀호출로 N 중 for문 구현
- N 입력 후 1 1 1 ... ~ 3 3 3 ... 출력하는 문제는 for문으로 구현이 어려움
- 아래처럼 재귀호출로 구현할 수 있다.

```py
path = []
N = 3

def run(lev):
    if lev == N:
        print(path)
        return
    for i in range(1, 4):
        path.append(i)
        run(lev + 1)
        path.pop()
    
# N = int(input())
run(0)
```

```
[1, 1, 1]
[1, 1, 2]
[1, 1, 3]
[1, 2, 1]
[1, 2, 2]
   
   ...
[3, 3, 3]
```

### 재귀를 연습하기 전, 알아야 할 함수의 특징
- KFC 함수 호출할 때, int 타입 객체를 전달하면 <mark>값만 복사됨</mark>
- 아래 예시에서, main 함수의 x와, KFC 함수의 x는 서로 다른 객체
    - 마치 한국 사는 KIM과 미국 사는 KIM이 이름만 같고, 서로 다른 사람인 것과 같다

![0904_완전_탐색_2025-09-04-09-22-52](images/0904_완전_탐색_2025-09-04-09-22-52.png)

- 아래 코드의 실행결과?

```py
def KFC(x):
    print(x)
    x += 1
    print(x)

x = 3
KFC(x + 1)
print(x)
```

![0904_완전_탐색_2025-09-04-09-25-24](images/0904_완전_탐색_2025-09-04-09-25-24.png)

- BTS 함수가 끝나면 Main으로 되돌아 오는 것이 아니라, <mark>해당 함수를 호출했던 곳으로 돌아옴</mark>
- 아래 코드의 실행 결과는?

```py
def BBQ(x):
    x += 10     # x = 19
    print(x)    # 19

def KFC(x):
    print(x)    # 4
    x += 3      # x = 7
    BBQ(x + 2)  # BBQ(9)
    print(x)    # 7

x = 3
KFC(x + 1)  # KFC(4)
print(x)    # 3
```

### [도전] 무한 재귀호출
- 아래 그림과 같은 코드를 직접 구현
    - 첫 번째 KFC 함수의 x 값은 0이 된다.
    - 두 번째 KFC 함수의 x 값은 1이 된다.
    - 세 번째 KFC 함수의 x 값은 2이 된다.

![0904_완전_탐색_2025-09-04-09-30-01](images/0904_완전_탐색_2025-09-04-09-30-01.png)

- 무한 재귀 호출이 발생하면 어떻게 되는지, 직접 코드를 작성하고 실행

### 재귀호출 공부의 시작은, 무한 재귀호출을 막는 것부터 시작
- 출력결과는 <mark>0 1 1 0</mark>
- 아래 if문을 <mark>"기저조건(base case)"</mark> 이라고 함

![0904_완전_탐색_2025-09-04-09-31-19](images/0904_완전_탐색_2025-09-04-09-31-19.png)

### [도전] 0 1 2 3 4 5 5 4 3 2 1 0 을 재귀호출을 이용하여 구현
- 몇 번 Depth에서 return 을 해야 하고, print 문을 어느 위치에 배치할지 고민

### 재귀호출 코드가 1개
- KFC 함수 내부에 KFC(x + 1) 재귀 호출 코드가 하나인 경우 예시 그림
    - 출력 결과는 <mark>1 0</mark>

![0904_완전_탐색_2025-09-04-09-43-25](images/0904_완전_탐색_2025-09-04-09-43-25.png)

### 재귀호출 코드가 2개
- KFC 함수 내부에 KFC(x + 1) 재귀 호출 코드가 두 개
    - 출력결과는 1 1 0

![0904_완전_탐색_2025-09-04-09-44-24](images/0904_완전_탐색_2025-09-04-09-44-24.png)

### 간략화하여 그리기

![0904_완전_탐색_2025-09-04-09-44-57](images/0904_완전_탐색_2025-09-04-09-44-57.png)

- <mark>아래 그림만 보고, 우측 코드를 구현할 수 있어야 함</mark>

![0904_완전_탐색_2025-09-04-09-45-35](images/0904_완전_탐색_2025-09-04-09-45-35.png)

### 재귀호출 코드가 3개
- KFC 함수 내부에 KFC(x + 1) 재귀 호출 코드가 세 개

![0904_완전_탐색_2025-09-04-09-46-41](images/0904_완전_탐색_2025-09-04-09-46-41.png)

### [도전] Depth 3, 재귀호출 개수 4개인 경우 그림 그려보기
- 그림판에 직접 트리형태로 그려보기

![0904_완전_탐색_2025-09-04-09-49-36](images/0904_완전_탐색_2025-09-04-09-49-36.png)

### 깊이를 Level이라고 부름
- <mark>Level은 3, Branch(나뭇가지)는 4</mark>인 형태의 코드를 for문으로도 표현 가능
- 반드시 아래 코드의 원리를 이해해야 함
    - 이제 <mark>순열</mark>을 학습할 준비를 마쳤음.


```py
def KFC(x):
    if x == 3:
        return
    
    for i in range(1, 4):
        KFC(x + 1)

KFC(0)
```

### [도전] 트리 형태를 보고 직접 재귀호출 코드 구현하기

![0904_완전_탐색_2025-09-04-10-00-19](images/0904_완전_탐색_2025-09-04-10-00-19.png)

## 순열

### 순열이란?
- 서로 다른 N개에서 R개를 중복없이 순서를 고려하여 나열하는 것
- 예시)
    - [0], [1], [2] 로 구성된 3장의 카드가 다량 존재
    - 이 중 2장을 뽑아 순열을 나열함<br><mark>(순열은 중복을 취급하지 않는다.)</mark>

![0904_완전_탐색_2025-09-04-10-03-32](images/0904_완전_탐색_2025-09-04-10-03-32.png)

### 중복순열이란?
- 서로 다른 N개에서 R개를 <mark>중복을 허용하고</mark>, 수넛를 고려하여 나열하는 것
- 예시)
    - [0], [1], [2] 로 구성된 3장의 카드가 다량 존재
    - 이 중 2장을 뽑아 중복순열을 나열함

![0904_완전_탐색_2025-09-04-10-05-03](images/0904_완전_탐색_2025-09-04-10-05-03.png)

### 중복순열 구현 원리
1. 재귀호출을 할 때마다 이동경로를 흔적으로 남김

![0904_완전_탐색_2025-09-04-10-06-06](images/0904_완전_탐색_2025-09-04-10-06-06.png)

2. 가장 마지막 레벨에 도착했을 때, 이동경로를 출력

![0904_완전_탐색_2025-09-04-10-06-30](images/0904_완전_탐색_2025-09-04-10-06-30.png)

### 순열(Permutation)
- 먼저 path 라는 전역 리스트를 준비한다.
- 그리고 Level 2, Branch 3으로 동작되는 재귀 코드를 구현
- <mark>재귀호출을 하기 직전에</mark> 이동할 곳의 위치를 path 리스트에 기록
- 재귀호출됨. 그리고 코드가 계속 진행되어 path.append(i)를 수행
- 두 번 재귀호출 되었고, 이제 바닥에 도달했으니 출력하는 코드 수행
- 함수가 리턴되고, 함수가 즉시 종료됨
- 이후 path에 적은 마지막 기록이 삭제되어야 함
- 이어서 for문이 진행되고 변수 i 값은 1이 됨
- path 배열 마지막에 1이 삽입됨
- 재귀호출이 된 후, path 리스트를 출력
- 중복 순열 소스코드 완성 -> [0, 0] ~ [2, 2] 까지 출력하는 소스코드

### [도전] 1부터 6까지 사용하는 중복순열([1, 1, 1] ~ [6, 6, 6])을 출력하는 코드를 재귀호출로 구현

### 중복을 취급하지 않는 "<mark>순열</mark>" 구현 방법
1. 중복순열 코드를 작성
2. <mark>중복을 제거하는 코드</mark>를 추가하면 순열 코드가 됨

### 중복을 제거하는 원리
- <mark>전역 리스트</mark>를 사용으로 이미 선택했던 숫자인지 아닌지 구분
- 이것을 used 배열 또는 visited 배열이라고 부름
    - DFS, BFS에 사용되는 것과 같다.

### 중복을 제거한 순열 생성 예시
- 0을 선택하고 재귀호출한 후, <mark>또 다시 0을 선택하지 못하도록 막아야 함</mark>
- <mark>재귀 호출을 하기 직전,</mark> 이미 선택했던 숫자인지 아닌지 검사하는 코드가 필요

![0904_완전_탐색_2025-09-04-10-22-51](images/0904_완전_탐색_2025-09-04-10-22-51.png)

- 이미 사용한 숫자인지 아닌지 구분하는 List 준비
    - 전역으로 used 라는 리스트를 준비

![0904_완전_탐색_2025-09-04-10-23-35](images/0904_완전_탐색_2025-09-04-10-23-35.png)

```py
path = []
used = [False, False, False]

def KFC(x):
    if x == 2:
        return

    for i in range(3):
        if used[i] == True:
            continue
        used[i] = True
        path.append(i)
        KFC(x + 1)
        path.pop()
        used[i] = False

KFC(0)
```

- <mark>이미 사용을 한 숫자인지 아닌지 검사해주는 소스코드 추가</mark>
- 만약 이미 사용한 숫자일 경우, 재귀호출을 생략하는 코드를 추가
- 처음 사용하는 숫자라면 <mark>used에 기록함</mark>
- 모든 처리가 끝나고 돌아왔다면, <mark>used에서 기록을 지움</mark>

### [도전] <mark>중복 순열</mark>과 <mark>순열</mark> 구현하기
- N개의 주사위를 던져 나올 수 있는 모든 중복 순열(Type 1)과 순열(Type 2)을 출력
- 입력)
    - N은 2이고 Type은 1이므로 중복 순열을 출력

## 완전탐색(Brute-Force)
모든 가능한 경우를 모두 시도를 해보아 정답을 찾아내는 알고리즘

### 완전탐색 예시
- 자전거 자물쇠 비밀번호 맞추기
    - 만약 1 1 1 1 ~ 9 9 9 9 네 자리 숫자를 맞춰야 한다면?<br>솔루션 -> 4중 for문으로 모드 시도해본다.
- 만약 1 ~ 9까지 이뤄진 N자리의 숫자를 맞춰야 한다면?<br>
솔루션 -> 순열 코드(재귀호출)로 구현하여, 모두 시도해봄

### 문제 1. 주사위 눈의 합
- 3개의 주사위를 던져 나올 수 있는 중복 순열에 대해 합이 10 이하가 나오는 경우는 촐 몇 가지인가?
- 먼저 합을 출력하는 코드를 작성
- 재귀호출을 할 때마다 선택한 값의 <mark>누적 합</mark>을 구함

![0904_완전_탐색_2025-09-04-14-28-30](images/0904_완전_탐색_2025-09-04-14-28-30.png)

```py
path = []

def kfc(x, sum):
    if x == 3:
        print(f'{path} = {sum}')
        return

    for i in range(1, 7):
        path.append(i)
        kfc(x + 1, sum + i)
        path.pop()

kfc(x: 0, sum: 0)
```

- 파라미터에 sum을 추가하여 구현
    - sum: 지금까지 구한 합
    - i: 선택한 주사위 눈금
- 재귀호출할 때 <mark>sum + i</mark> 값을 전달
---
- Sum이 10 이하일 때만 출력
- 실제로는 모두 탐색하지만, 모두 출력하지 않는 방법

![0904_완전_탐색_2025-09-04-14-31-29](images/0904_완전_탐색_2025-09-04-14-31-29.png)

- 가지치기: 답이 아닌 것에 대해 즉시 되돌아감

![0904_완전_탐색_2025-09-04-14-32-09](images/0904_완전_탐색_2025-09-04-14-32-09.png)

- 합이 10 이하가 되는 경우의 수를 구하는 코드
    - 완성된 코드에서 시작
- 합이 10 이하일 때를 찾을 때마다, cnt += 1을 수행
    - cnt 값이 정답이 된다
    - 결과 108이 출력됨

```py
path = []
cnt = 0

def kfc(x, sum):
    global cnt
    if sum > 10:
        return

    if x == 3:
        # print(f'{path} = {sum}')
        cnt += 1
        return

    for i in range(1, 7):
        path.append(i)
        kfc(x + 1, sum + i)
        path.pop()

kfc(x: 0, sum: 0)
print(cnt)
```

### 완전탐색 문제 2. 연속 3장의 트럼프 카드
- A, J, Q, K 네 종류의 카드들이 충분히 있음
- 이 중 5장의 카드를 뽑아 나열
    - A A A A A
    - A A A A J
    - ...
    - K K K K K
- 같은 종류의 카드가 <mark>세 장 연속</mark>으로 나오는 경우의 수는?
---
- 모든 경우에 대해 다 시도하기
1. 순열 코드를 작성
    - 먼저 [A, J, Q, K] 카드에 대해 [AAAAA ~ KKKKK] 까지 출력
2. 같은 종류의 카드가 연속 3장이 나왔다면 Counting
---
- 순열 코드 작성하기
    - [AAAAA] ~ [KKKKK]
- Branch는 4개, Level은 5개까지 탐색

![0904_완전_탐색_2025-09-04-14-36-58](images/0904_완전_탐색_2025-09-04-14-36-58.png)

- 같은 카드가 연속 세 장인지 검사하는 코드
- cont_three(0)
    - 연속 세 장이 있으면 True를 리턴
    - 아니면 False를 리턴

```py
def cont_three():
    if path[0] == path[1] == path[2]: return True
    if path[1] == path[2] == path[3]: return True
    if path[2] == path[3] == path[4]: return True
    return False
```

- 전체 코드

![0904_완전_탐색_2025-09-04-15-07-55](images/0904_완전_탐색_2025-09-04-15-07-55.png)

### 완전탐색 문제 3. Baby-gin
- 0 이상 9 이하의 번호가 적힌 6장의 카드

![0904_완전_탐색_2025-09-04-15-08-25](images/0904_완전_탐색_2025-09-04-15-08-25.png)

- 3장의 카드가 연속적인 번호를 갖는 경우 "run" 이라고 하고,<br>3장의 카드가 동일한 번호를 갖는 경우는 "triplet" 이라고 한다.
- 그리고 6장의 카드가 run과 triplet으로만 구성된 경우를 "baby-gin"으로 부릅니다.<br>(위 예시에서는 0 1 2 와 7 7 7 카드가 있으므로 baby-gin이다.)

- 6장의 카드 번호를 입력받고, <mark>완전탐색</mark>으로 baby-gin 여부를 판단하는 프로그램을 작성하기
---
- 입력 예시
    - 667767 -> 두 개의 triplet이므로 <mark>baby-gin</mark> 이다. (666, 777)
    - 054060 -> 한 개의 run과 한 개의 triplet이므로 역시 <mark>baby-gin</mark> 이다. (456, 000)
    - 101123<br>-> 한 개의 triplet(111)이 존재하나, 나머지 023이 triplet, run이 아니다.<br>-> 한 개의 run(123)이 존재하나, 나머지 011이 triplet, run이 아니다.<br>-> 한 개의 run(012)이 존재하나, 나머지 113이 triplet, run이 아니다.<br>-> <mark>따라서 baby-gin이 아니다.</mark>
- <mark>완전탐색</mark>을 이용해 baby-gin 여부를 검사하는 프로그램 작성하기
---
- 풀이 힌트 1. 고려할 수 있는 모든 경우의 수 생성하기
    - 6개의 카드로 만들 수 있는 모든 순서를 나열 = "순열" 코드를 작성
- 예) 입력으로 {2, 3, 5, 7, 7, 7}을 받았을 경우, 그림과 같이 순열을 생성

![0904_완전_탐색_2025-09-04-15-19-24](images/0904_완전_탐색_2025-09-04-15-19-24.png)

- 풀이 힌트 2. 검사하는 함수를 제작하여 하나씩 테스트
- **is_baby_gin() 함수를 제작**
    - 앞 3자리가 run 또는 triplet이면서<br>뒤 3자리가 run 또는 triplet이면 True를 리턴
    - 그렇지 않으면 False를 리턴
- 많은 순열 중, 하나라도 True라면 Baby-gin

## 연습 문제

### 연습문제 1: Baby-gin
- 6자리 숫자를 입력받은 후, 완전탐색을 적용하여 Baby-gin 여부를 검사하는 프로그램을 작성<br>(Yes / No 를 출력)
- 입력 / 출력 예시
    - 1 2 4 7 8 3 -> No
    - 6 6 7 7 6 7 -> Yes
    - 0 5 4 0 6 0 -> Yes
    - 1 0 1 1 2 3 -> No

## 실습 문제

### 실습 문제1 - 5188. 최소합
1. (0, 0) 에서 출발하여 우, 하로만 이동할 수 있다.
2. 숫자 판을 밟을 때마다 에너지가 소모된다.
3. (N - 1, N - 1) 에 도착했을 때 최소 에너지 소모량의 합계를 구하라

![0904_완전_탐색_2025-09-04-15-23-08](images/0904_완전_탐색_2025-09-04-15-23-08.png)

### 실습 문제2 - 5189. 전자카트
1. 1 ~ N번 구역이 있다. 각 구역에서 다른 구역으로 카트를 타고 이동한다. 이동할 때마다 배터리가 소모되며, 아래 그림은 소모되는 비용을 나타낸다.
2. 1번 구역에서 출발해서 모든 구역을 다 한 번씩 들린 후, 다시 1번으로 돌아오려 한다.
3. 최소 배터리 소모량을 출력하라.

![0904_완전_탐색_2025-09-04-15-24-34](images/0904_완전_탐색_2025-09-04-15-24-34.png)

### 실습
- 완전탐색
    - 5188. 최소합
- 순열
    - 5189. 전자카트
- 재귀
    - 2105. [모의 SW 역량테스트] 디저트 카페
- 추가 연습
    - 1247. [S/W 문제해결 응용] 3일차 - 최적 경로
    - 1244. 최대상금
